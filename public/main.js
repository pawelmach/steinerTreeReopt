(() => { var e = { 3796: e => { e.exports = function (e, t) { var r = t.length; if (0 !== r) { var n = e.length; e.length += r; for (var i = 0; i < r; i++)e[n + i] = t[i] } } }, 4802: (e, t, r) => { t.formatArgs = function (t) { if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors) return; const r = "color: " + this.color; t.splice(1, 0, r, "color: inherit"); let n = 0, i = 0; t[0].replace(/%[a-zA-Z%]/g, (e => { "%%" !== e && (n++, "%c" === e && (i = n)) })), t.splice(i, 0, r) }, t.save = function (e) { try { e ? t.storage.setItem("debug", e) : t.storage.removeItem("debug") } catch (e) { } }, t.load = function () { let e; try { e = t.storage.getItem("debug") } catch (e) { } return !e && "undefined" != typeof process && "env" in process && (e = process.env.DEBUG), e }, t.useColors = function () { return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)) }, t.storage = function () { try { return localStorage } catch (e) { } }(), t.destroy = (() => { let e = !1; return () => { e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")) } })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => { }), e.exports = r(804)(t); const { formatters: n } = e.exports; n.j = function (e) { try { return JSON.stringify(e) } catch (e) { return "[UnexpectedJSONParseError]: " + e.message } } }, 804: (e, t, r) => { e.exports = function (e) { function t(e) { let r, i, o, a = null; function s(...e) { if (!s.enabled) return; const n = s, i = Number(new Date), o = i - (r || i); n.diff = o, n.prev = r, n.curr = i, r = i, e[0] = t.coerce(e[0]), "string" != typeof e[0] && e.unshift("%O"); let a = 0; e[0] = e[0].replace(/%([a-zA-Z%])/g, ((r, i) => { if ("%%" === r) return "%"; a++; const o = t.formatters[i]; if ("function" == typeof o) { const t = e[a]; r = o.call(n, t), e.splice(a, 1), a-- } return r })), t.formatArgs.call(n, e), (n.log || t.log).apply(n, e) } return s.namespace = e, s.useColors = t.useColors(), s.color = t.selectColor(e), s.extend = n, s.destroy = t.destroy, Object.defineProperty(s, "enabled", { enumerable: !0, configurable: !1, get: () => null !== a ? a : (i !== t.namespaces && (i = t.namespaces, o = t.enabled(e)), o), set: e => { a = e } }), "function" == typeof t.init && t.init(s), s } function n(e, r) { const n = t(this.namespace + (void 0 === r ? ":" : r) + e); return n.log = this.log, n } function i(e) { return e.toString().substring(2, e.toString().length - 2).replace(/\.\*\?$/, "*") } return t.debug = t, t.default = t, t.coerce = function (e) { return e instanceof Error ? e.stack || e.message : e }, t.disable = function () { const e = [...t.names.map(i), ...t.skips.map(i).map((e => "-" + e))].join(","); return t.enable(""), e }, t.enable = function (e) { let r; t.save(e), t.namespaces = e, t.names = [], t.skips = []; const n = ("string" == typeof e ? e : "").split(/[\s,]+/), i = n.length; for (r = 0; r < i; r++)n[r] && ("-" === (e = n[r].replace(/\*/g, ".*?"))[0] ? t.skips.push(new RegExp("^" + e.slice(1) + "$")) : t.names.push(new RegExp("^" + e + "$"))) }, t.enabled = function (e) { if ("*" === e[e.length - 1]) return !0; let r, n; for (r = 0, n = t.skips.length; r < n; r++)if (t.skips[r].test(e)) return !1; for (r = 0, n = t.names.length; r < n; r++)if (t.names[r].test(e)) return !0; return !1 }, t.humanize = r(810), t.destroy = function () { console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.") }, Object.keys(e).forEach((r => { t[r] = e[r] })), t.names = [], t.skips = [], t.formatters = {}, t.selectColor = function (e) { let r = 0; for (let t = 0; t < e.length; t++)r = (r << 5) - r + e.charCodeAt(t), r |= 0; return t.colors[Math.abs(r) % t.colors.length] }, t.enable(t.load()), t } }, 810: e => { var t = 1e3, r = 60 * t, n = 60 * r, i = 24 * n; function o(e, t, r, n) { var i = t >= 1.5 * r; return Math.round(e / r) + " " + n + (i ? "s" : "") } e.exports = function (e, a) { a = a || {}; var s, c, u = typeof e; if ("string" === u && e.length > 0) return function (e) { if (!((e = String(e)).length > 100)) { var o = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e); if (o) { var a = parseFloat(o[1]); switch ((o[2] || "ms").toLowerCase()) { case "years": case "year": case "yrs": case "yr": case "y": return 315576e5 * a; case "weeks": case "week": case "w": return 6048e5 * a; case "days": case "day": case "d": return a * i; case "hours": case "hour": case "hrs": case "hr": case "h": return a * n; case "minutes": case "minute": case "mins": case "min": case "m": return a * r; case "seconds": case "second": case "secs": case "sec": case "s": return a * t; case "milliseconds": case "millisecond": case "msecs": case "msec": case "ms": return a; default: return } } } }(e); if ("number" === u && isFinite(e)) return a.long ? (s = e, (c = Math.abs(s)) >= i ? o(s, c, i, "day") : c >= n ? o(s, c, n, "hour") : c >= r ? o(s, c, r, "minute") : c >= t ? o(s, c, t, "second") : s + " ms") : function (e) { var o = Math.abs(e); return o >= i ? Math.round(e / i) + "d" : o >= n ? Math.round(e / n) + "h" : o >= r ? Math.round(e / r) + "m" : o >= t ? Math.round(e / t) + "s" : e + "ms" }(e); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e)) } }, 7187: e => { "use strict"; var t, r = "object" == typeof Reflect ? Reflect : null, n = r && "function" == typeof r.apply ? r.apply : function (e, t, r) { return Function.prototype.apply.call(e, t, r) }; t = r && "function" == typeof r.ownKeys ? r.ownKeys : Object.getOwnPropertySymbols ? function (e) { return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)) } : function (e) { return Object.getOwnPropertyNames(e) }; var i = Number.isNaN || function (e) { return e != e }; function o() { o.init.call(this) } e.exports = o, e.exports.once = function (e, t) { return new Promise((function (r, n) { function i(r) { e.removeListener(t, o), n(r) } function o() { "function" == typeof e.removeListener && e.removeListener("error", i), r([].slice.call(arguments)) } g(e, t, o, { once: !0 }), "error" !== t && function (e, t, r) { "function" == typeof e.on && g(e, "error", t, { once: !0 }) }(e, i) })) }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0; var a = 10; function s(e) { if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e) } function c(e) { return void 0 === e._maxListeners ? o.defaultMaxListeners : e._maxListeners } function u(e, t, r, n) { var i, o, a, u; if (s(r), void 0 === (o = e._events) ? (o = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== o.newListener && (e.emit("newListener", t, r.listener ? r.listener : r), o = e._events), a = o[t]), void 0 === a) a = o[t] = r, ++e._eventsCount; else if ("function" == typeof a ? a = o[t] = n ? [r, a] : [a, r] : n ? a.unshift(r) : a.push(r), (i = c(e)) > 0 && a.length > i && !a.warned) { a.warned = !0; var h = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit"); h.name = "MaxListenersExceededWarning", h.emitter = e, h.type = t, h.count = a.length, u = h, console && console.warn && console.warn(u) } return e } function h() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function d(e, t, r) { var n = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, i = h.bind(n); return i.listener = r, n.wrapFn = i, i } function l(e, t, r) { var n = e._events; if (void 0 === n) return []; var i = n[t]; return void 0 === i ? [] : "function" == typeof i ? r ? [i.listener || i] : [i] : r ? function (e) { for (var t = new Array(e.length), r = 0; r < t.length; ++r)t[r] = e[r].listener || e[r]; return t }(i) : f(i, i.length) } function p(e) { var t = this._events; if (void 0 !== t) { var r = t[e]; if ("function" == typeof r) return 1; if (void 0 !== r) return r.length } return 0 } function f(e, t) { for (var r = new Array(t), n = 0; n < t; ++n)r[n] = e[n]; return r } function g(e, t, r, n) { if ("function" == typeof e.on) n.once ? e.once(t, r) : e.on(t, r); else { if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e); e.addEventListener(t, (function i(o) { n.once && e.removeEventListener(t, i), r(o) })) } } Object.defineProperty(o, "defaultMaxListeners", { enumerable: !0, get: function () { return a }, set: function (e) { if ("number" != typeof e || e < 0 || i(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + "."); a = e } }), o.init = function () { void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }, o.prototype.setMaxListeners = function (e) { if ("number" != typeof e || e < 0 || i(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + "."); return this._maxListeners = e, this }, o.prototype.getMaxListeners = function () { return c(this) }, o.prototype.emit = function (e) { for (var t = [], r = 1; r < arguments.length; r++)t.push(arguments[r]); var i = "error" === e, o = this._events; if (void 0 !== o) i = i && void 0 === o.error; else if (!i) return !1; if (i) { var a; if (t.length > 0 && (a = t[0]), a instanceof Error) throw a; var s = new Error("Unhandled error." + (a ? " (" + a.message + ")" : "")); throw s.context = a, s } var c = o[e]; if (void 0 === c) return !1; if ("function" == typeof c) n(c, this, t); else { var u = c.length, h = f(c, u); for (r = 0; r < u; ++r)n(h[r], this, t) } return !0 }, o.prototype.addListener = function (e, t) { return u(this, e, t, !1) }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function (e, t) { return u(this, e, t, !0) }, o.prototype.once = function (e, t) { return s(t), this.on(e, d(this, e, t)), this }, o.prototype.prependOnceListener = function (e, t) { return s(t), this.prependListener(e, d(this, e, t)), this }, o.prototype.removeListener = function (e, t) { var r, n, i, o, a; if (s(t), void 0 === (n = this._events)) return this; if (void 0 === (r = n[e])) return this; if (r === t || r.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, r.listener || t)); else if ("function" != typeof r) { for (i = -1, o = r.length - 1; o >= 0; o--)if (r[o] === t || r[o].listener === t) { a = r[o].listener, i = o; break } if (i < 0) return this; 0 === i ? r.shift() : function (e, t) { for (; t + 1 < e.length; t++)e[t] = e[t + 1]; e.pop() }(r, i), 1 === r.length && (n[e] = r[0]), void 0 !== n.removeListener && this.emit("removeListener", e, a || t) } return this }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function (e) { var t, r, n; if (void 0 === (r = this._events)) return this; if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[e]), this; if (0 === arguments.length) { var i, o = Object.keys(r); for (n = 0; n < o.length; ++n)"removeListener" !== (i = o[n]) && this.removeAllListeners(i); return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this } if ("function" == typeof (t = r[e])) this.removeListener(e, t); else if (void 0 !== t) for (n = t.length - 1; n >= 0; n--)this.removeListener(e, t[n]); return this }, o.prototype.listeners = function (e) { return l(this, e, !0) }, o.prototype.rawListeners = function (e) { return l(this, e, !1) }, o.listenerCount = function (e, t) { return "function" == typeof e.listenerCount ? e.listenerCount(t) : p.call(e, t) }, o.prototype.listenerCount = p, o.prototype.eventNames = function () { return this._eventsCount > 0 ? t(this._events) : [] } }, 1847: e => { e.exports = { linLogMode: !1, outboundAttractionDistribution: !1, adjustSizes: !1, edgeWeightInfluence: 1, scalingRatio: 1, strongGravityMode: !1, gravity: 1, slowDown: 1, barnesHutOptimize: !1, barnesHutTheta: .5 } }, 1739: (e, t) => { t.assign = function (e) { e = e || {}; var t, r, n, i = Array.prototype.slice.call(arguments).slice(1); for (t = 0, n = i.length; t < n; t++)if (i[t]) for (r in i[t]) e[r] = i[t][r]; return e }, t.validateSettings = function (e) { return "linLogMode" in e && "boolean" != typeof e.linLogMode ? { message: "the `linLogMode` setting should be a boolean." } : "outboundAttractionDistribution" in e && "boolean" != typeof e.outboundAttractionDistribution ? { message: "the `outboundAttractionDistribution` setting should be a boolean." } : "adjustSizes" in e && "boolean" != typeof e.adjustSizes ? { message: "the `adjustSizes` setting should be a boolean." } : "edgeWeightInfluence" in e && "number" != typeof e.edgeWeightInfluence ? { message: "the `edgeWeightInfluence` setting should be a number." } : !("scalingRatio" in e) || "number" == typeof e.scalingRatio && e.scalingRatio >= 0 ? "strongGravityMode" in e && "boolean" != typeof e.strongGravityMode ? { message: "the `strongGravityMode` setting should be a boolean." } : !("gravity" in e) || "number" == typeof e.gravity && e.gravity >= 0 ? "slowDown" in e && !("number" == typeof e.slowDown || e.slowDown >= 0) ? { message: "the `slowDown` setting should be a number >= 0." } : "barnesHutOptimize" in e && "boolean" != typeof e.barnesHutOptimize ? { message: "the `barnesHutOptimize` setting should be a boolean." } : !("barnesHutTheta" in e) || "number" == typeof e.barnesHutTheta && e.barnesHutTheta >= 0 ? null : { message: "the `barnesHutTheta` setting should be a number >= 0." } : { message: "the `gravity` setting should be a number >= 0." } : { message: "the `scalingRatio` setting should be a number >= 0." } }, t.graphToByteArrays = function (e, t) { var r, n = e.order, i = e.size, o = {}, a = new Float32Array(10 * n), s = new Float32Array(3 * i); return r = 0, e.forEachNode((function (t, n) { o[t] = r, a[r] = n.x, a[r + 1] = n.y, a[r + 2] = 0, a[r + 3] = 0, a[r + 4] = 0, a[r + 5] = 0, a[r + 6] = 1 + e.degree(t), a[r + 7] = 1, a[r + 8] = n.size || 1, a[r + 9] = n.fixed ? 1 : 0, r += 10 })), r = 0, e.forEachEdge((function (e, n, i, a, c, u, h) { s[r] = o[i], s[r + 1] = o[a], s[r + 2] = t(e, n, i, a, c, u, h), r += 3 })), { nodes: a, edges: s } }, t.assignLayoutChanges = function (e, t, r) { var n = 0; e.updateEachNodeAttributes((function (e, i) { return i.x = t[n], i.y = t[n + 1], n += 10, r ? r(e, i) : i })) }, t.readGraphPositions = function (e, t) { var r = 0; e.forEachNode((function (e, n) { t[r] = n.x, t[r + 1] = n.y, r += 10 })) }, t.collectLayoutChanges = function (e, t, r) { for (var n = e.nodes(), i = {}, o = 0, a = 0, s = t.length; o < s; o += 10) { if (r) { var c = Object.assign({}, e.getNodeAttributes(n[a])); c.x = t[o], c.y = t[o + 1], c = r(n[a], c), i[n[a]] = { x: c.x, y: c.y } } else i[n[a]] = { x: t[o], y: t[o + 1] }; a++ } return i }, t.createWorker = function (e) { var t = window.URL || window.webkitURL, r = e.toString(), n = t.createObjectURL(new Blob(["(" + r + ").call(this);"], { type: "text/javascript" })), i = new Worker(n); return t.revokeObjectURL(n), i } }, 9404: (e, t, r) => { var n = r(6186), i = r(2308).Q6, o = r(7810), a = r(1739), s = r(1847); function c(e, t, r) { if (!n(t)) throw new Error("graphology-layout-forceatlas2: the given graph is not a valid graphology instance."); "number" == typeof r && (r = { iterations: r }); var c = r.iterations; if ("number" != typeof c) throw new Error("graphology-layout-forceatlas2: invalid number of iterations."); if (c <= 0) throw new Error("graphology-layout-forceatlas2: you should provide a positive number of iterations."); var u = i(r.getEdgeWeight).fromEntry, h = "function" == typeof r.outputReducer ? r.outputReducer : null, d = a.assign({}, s, r.settings), l = a.validateSettings(d); if (l) throw new Error("graphology-layout-forceatlas2: " + l.message); var p, f = a.graphToByteArrays(t, u); for (p = 0; p < c; p++)o(d, f.nodes, f.edges); if (!e) return a.collectLayoutChanges(t, f.nodes); a.assignLayoutChanges(t, f.nodes, h) } var u = c.bind(null, !1); u.assign = c.bind(null, !0), u.inferSettings = function (e) { var t = "number" == typeof e ? e : e.order; return { barnesHutOptimize: t > 2e3, strongGravityMode: !0, gravity: .05, scalingRatio: 10, slowDown: 1 + Math.log(t) } }, e.exports = u }, 7810: e => { var t = 10; e.exports = function (e, r, n) { var i, o, a, s, c, u, h, d, l, p, f, g, y, m, v, b, w, _, x, E, C, k, L, A = r.length, S = n.length, F = e.adjustSizes, T = e.barnesHutTheta * e.barnesHutTheta, O = []; for (a = 0; a < A; a += t)r[a + 4] = r[a + 2], r[a + 5] = r[a + 3], r[a + 2] = 0, r[a + 3] = 0; if (e.outboundAttractionDistribution) { for (f = 0, a = 0; a < A; a += t)f += r[a + 6]; f /= A / t } if (e.barnesHutOptimize) { var P, M, R, D = 1 / 0, G = -1 / 0, N = 1 / 0, j = -1 / 0; for (a = 0; a < A; a += t)D = Math.min(D, r[a + 0]), G = Math.max(G, r[a + 0]), N = Math.min(N, r[a + 1]), j = Math.max(j, r[a + 1]); var B = G - D, z = j - N; for (B > z ? j = (N -= (B - z) / 2) + B : G = (D -= (z - B) / 2) + z, O[0] = -1, O[1] = (D + G) / 2, O[2] = (N + j) / 2, O[3] = Math.max(G - D, j - N), O[4] = -1, O[5] = -1, O[6] = 0, O[7] = 0, O[8] = 0, i = 1, a = 0; a < A; a += t)for (o = 0, R = 3; ;) { if (!(O[o + 5] >= 0)) { if (O[o + 0] < 0) { O[o + 0] = a; break } if (O[o + 5] = 9 * i, d = O[o + 3] / 2, O[(l = O[o + 5]) + 0] = -1, O[l + 1] = O[o + 1] - d, O[l + 2] = O[o + 2] - d, O[l + 3] = d, O[l + 4] = l + 9, O[l + 5] = -1, O[l + 6] = 0, O[l + 7] = 0, O[l + 8] = 0, O[(l += 9) + 0] = -1, O[l + 1] = O[o + 1] - d, O[l + 2] = O[o + 2] + d, O[l + 3] = d, O[l + 4] = l + 9, O[l + 5] = -1, O[l + 6] = 0, O[l + 7] = 0, O[l + 8] = 0, O[(l += 9) + 0] = -1, O[l + 1] = O[o + 1] + d, O[l + 2] = O[o + 2] - d, O[l + 3] = d, O[l + 4] = l + 9, O[l + 5] = -1, O[l + 6] = 0, O[l + 7] = 0, O[l + 8] = 0, O[(l += 9) + 0] = -1, O[l + 1] = O[o + 1] + d, O[l + 2] = O[o + 2] + d, O[l + 3] = d, O[l + 4] = O[o + 4], O[l + 5] = -1, O[l + 6] = 0, O[l + 7] = 0, O[l + 8] = 0, i += 4, P = r[O[o + 0] + 0] < O[o + 1] ? r[O[o + 0] + 1] < O[o + 2] ? O[o + 5] : O[o + 5] + 9 : r[O[o + 0] + 1] < O[o + 2] ? O[o + 5] + 18 : O[o + 5] + 27, O[o + 6] = r[O[o + 0] + 6], O[o + 7] = r[O[o + 0] + 0], O[o + 8] = r[O[o + 0] + 1], O[P + 0] = O[o + 0], O[o + 0] = -1, P === (M = r[a + 0] < O[o + 1] ? r[a + 1] < O[o + 2] ? O[o + 5] : O[o + 5] + 9 : r[a + 1] < O[o + 2] ? O[o + 5] + 18 : O[o + 5] + 27)) { if (R--) { o = P; continue } R = 3; break } O[M + 0] = a; break } P = r[a + 0] < O[o + 1] ? r[a + 1] < O[o + 2] ? O[o + 5] : O[o + 5] + 9 : r[a + 1] < O[o + 2] ? O[o + 5] + 18 : O[o + 5] + 27, O[o + 7] = (O[o + 7] * O[o + 6] + r[a + 0] * r[a + 6]) / (O[o + 6] + r[a + 6]), O[o + 8] = (O[o + 8] * O[o + 6] + r[a + 1] * r[a + 6]) / (O[o + 6] + r[a + 6]), O[o + 6] += r[a + 6], o = P } } if (e.barnesHutOptimize) { for (g = e.scalingRatio, a = 0; a < A; a += t)for (o = 0; ;)if (O[o + 5] >= 0) { if (b = Math.pow(r[a + 0] - O[o + 7], 2) + Math.pow(r[a + 1] - O[o + 8], 2), 4 * (p = O[o + 3]) * p / b < T) { if (y = r[a + 0] - O[o + 7], m = r[a + 1] - O[o + 8], !0 === F ? b > 0 ? (w = g * r[a + 6] * O[o + 6] / b, r[a + 2] += y * w, r[a + 3] += m * w) : b < 0 && (w = -g * r[a + 6] * O[o + 6] / Math.sqrt(b), r[a + 2] += y * w, r[a + 3] += m * w) : b > 0 && (w = g * r[a + 6] * O[o + 6] / b, r[a + 2] += y * w, r[a + 3] += m * w), (o = O[o + 4]) < 0) break; continue } o = O[o + 5] } else if ((u = O[o + 0]) >= 0 && u !== a && (b = (y = r[a + 0] - r[u + 0]) * y + (m = r[a + 1] - r[u + 1]) * m, !0 === F ? b > 0 ? (w = g * r[a + 6] * r[u + 6] / b, r[a + 2] += y * w, r[a + 3] += m * w) : b < 0 && (w = -g * r[a + 6] * r[u + 6] / Math.sqrt(b), r[a + 2] += y * w, r[a + 3] += m * w) : b > 0 && (w = g * r[a + 6] * r[u + 6] / b, r[a + 2] += y * w, r[a + 3] += m * w)), (o = O[o + 4]) < 0) break } else for (g = e.scalingRatio, s = 0; s < A; s += t)for (c = 0; c < s; c += t)y = r[s + 0] - r[c + 0], m = r[s + 1] - r[c + 1], !0 === F ? (b = Math.sqrt(y * y + m * m) - r[s + 8] - r[c + 8]) > 0 ? (w = g * r[s + 6] * r[c + 6] / b / b, r[s + 2] += y * w, r[s + 3] += m * w, r[c + 2] += y * w, r[c + 3] += m * w) : b < 0 && (w = 100 * g * r[s + 6] * r[c + 6], r[s + 2] += y * w, r[s + 3] += m * w, r[c + 2] -= y * w, r[c + 3] -= m * w) : (b = Math.sqrt(y * y + m * m)) > 0 && (w = g * r[s + 6] * r[c + 6] / b / b, r[s + 2] += y * w, r[s + 3] += m * w, r[c + 2] -= y * w, r[c + 3] -= m * w); for (l = e.gravity / e.scalingRatio, g = e.scalingRatio, a = 0; a < A; a += t)w = 0, y = r[a + 0], m = r[a + 1], b = Math.sqrt(Math.pow(y, 2) + Math.pow(m, 2)), e.strongGravityMode ? b > 0 && (w = g * r[a + 6] * l) : b > 0 && (w = g * r[a + 6] * l / b), r[a + 2] -= y * w, r[a + 3] -= m * w; for (g = 1 * (e.outboundAttractionDistribution ? f : 1), h = 0; h < S; h += 3)s = n[h + 0], c = n[h + 1], d = n[h + 2], v = Math.pow(d, e.edgeWeightInfluence), y = r[s + 0] - r[c + 0], m = r[s + 1] - r[c + 1], !0 === F ? (b = Math.sqrt(Math.pow(y, 2) + Math.pow(m, 2) - r[s + 8] - r[c + 8]), e.linLogMode ? e.outboundAttractionDistribution ? b > 0 && (w = -g * v * Math.log(1 + b) / b / r[s + 6]) : b > 0 && (w = -g * v * Math.log(1 + b) / b) : e.outboundAttractionDistribution ? b > 0 && (w = -g * v / r[s + 6]) : b > 0 && (w = -g * v)) : (b = Math.sqrt(Math.pow(y, 2) + Math.pow(m, 2)), e.linLogMode ? e.outboundAttractionDistribution ? b > 0 && (w = -g * v * Math.log(1 + b) / b / r[s + 6]) : b > 0 && (w = -g * v * Math.log(1 + b) / b) : e.outboundAttractionDistribution ? (b = 1, w = -g * v / r[s + 6]) : (b = 1, w = -g * v)), b > 0 && (r[s + 2] += y * w, r[s + 3] += m * w, r[c + 2] -= y * w, r[c + 3] -= m * w); if (!0 === F) for (a = 0; a < A; a += t)1 !== r[a + 9] && ((_ = Math.sqrt(Math.pow(r[a + 2], 2) + Math.pow(r[a + 3], 2))) > 10 && (r[a + 2] = 10 * r[a + 2] / _, r[a + 3] = 10 * r[a + 3] / _), x = r[a + 6] * Math.sqrt((r[a + 4] - r[a + 2]) * (r[a + 4] - r[a + 2]) + (r[a + 5] - r[a + 3]) * (r[a + 5] - r[a + 3])), E = Math.sqrt((r[a + 4] + r[a + 2]) * (r[a + 4] + r[a + 2]) + (r[a + 5] + r[a + 3]) * (r[a + 5] + r[a + 3])) / 2, C = .1 * Math.log(1 + E) / (1 + Math.sqrt(x)), k = r[a + 0] + r[a + 2] * (C / e.slowDown), r[a + 0] = k, L = r[a + 1] + r[a + 3] * (C / e.slowDown), r[a + 1] = L); else for (a = 0; a < A; a += t)1 !== r[a + 9] && (x = r[a + 6] * Math.sqrt((r[a + 4] - r[a + 2]) * (r[a + 4] - r[a + 2]) + (r[a + 5] - r[a + 3]) * (r[a + 5] - r[a + 3])), E = Math.sqrt((r[a + 4] + r[a + 2]) * (r[a + 4] + r[a + 2]) + (r[a + 5] + r[a + 3]) * (r[a + 5] + r[a + 3])) / 2, C = r[a + 7] * Math.log(1 + E) / (1 + Math.sqrt(x)), r[a + 7] = Math.min(1, Math.sqrt(C * (Math.pow(r[a + 2], 2) + Math.pow(r[a + 3], 2)) / (1 + Math.sqrt(x)))), k = r[a + 0] + r[a + 2] * (C / e.slowDown), r[a + 0] = k, L = r[a + 1] + r[a + 3] * (C / e.slowDown), r[a + 1] = L); return {} } }, 2308: (e, t) => { function r(e) { return "number" != typeof e || isNaN(e) ? 1 : e } t.Q6 = function (e) { return function (e, t) { var r = {}, n = function (e) { return void 0 === e ? t : e }; "function" == typeof t && (n = t); var i = function (t) { return n(t[e]) }, o = function () { return n(void 0) }; return "string" == typeof e ? (r.fromAttributes = i, r.fromGraph = function (e, t) { return i(e.getEdgeAttributes(t)) }, r.fromEntry = function (e, t) { return i(t) }, r.fromPartialEntry = r.fromEntry, r.fromMinimalEntry = r.fromEntry) : "function" == typeof e ? (r.fromAttributes = function () { throw new Error("graphology-utils/getters/createEdgeValueGetter: irrelevant usage.") }, r.fromGraph = function (t, r) { var i = t.extremities(r); return n(e(r, t.getEdgeAttributes(r), i[0], i[1], t.getNodeAttributes(i[0]), t.getNodeAttributes(i[1]), t.isUndirected(r))) }, r.fromEntry = function (t, r, i, o, a, s, c) { return n(e(t, r, i, o, a, s, c)) }, r.fromPartialEntry = function (t, r, i, o) { return n(e(t, r, i, o)) }, r.fromMinimalEntry = function (t, r) { return n(e(t, r)) }) : (r.fromAttributes = o, r.fromGraph = o, r.fromEntry = o, r.fromMinimalEntry = o), r }(e, r) } }, 6186: e => { e.exports = function (e) { return null !== e && "object" == typeof e && "function" == typeof e.addUndirectedEdgeWithKey && "function" == typeof e.dropNode && "boolean" == typeof e.multi } }, 2698: function (e) { e.exports = function () { "use strict"; function e(t) { return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(t) } function t(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, n(e, t) } function r(e) { return r = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, r(e) } function n(e, t) { return n = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e }, n(e, t) } function i() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (e) { return !1 } } function o(e, t, r) { return o = i() ? Reflect.construct : function (e, t, r) { var i = [null]; i.push.apply(i, t); var o = new (Function.bind.apply(e, i)); return r && n(o, r.prototype), o }, o.apply(null, arguments) } function a(e) { var t = "function" == typeof Map ? new Map : void 0; return a = function (e) { if (null === e || (i = e, -1 === Function.toString.call(i).indexOf("[native code]"))) return e; var i; if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== t) { if (t.has(e)) return t.get(e); t.set(e, a) } function a() { return o(e, arguments, r(this).constructor) } return a.prototype = Object.create(e.prototype, { constructor: { value: a, enumerable: !1, writable: !0, configurable: !0 } }), n(a, e) }, a(e) } function s(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } var c = function () { for (var e = arguments[0], t = 1, r = arguments.length; t < r; t++)if (arguments[t]) for (var n in arguments[t]) e[n] = arguments[t][n]; return e }; function u(e, t, r, n) { var i = e._nodes.get(t), o = null; return i ? o = "mixed" === n ? i.out && i.out[r] || i.undirected && i.undirected[r] : "directed" === n ? i.out && i.out[r] : i.undirected && i.undirected[r] : o } function h(t) { return null !== t && "object" === e(t) && "function" == typeof t.addUndirectedEdgeWithKey && "function" == typeof t.dropNode } function d(t) { return "object" === e(t) && null !== t && t.constructor === Object } function l(e) { var t; for (t in e) return !1; return !0 } function p(e, t, r) { Object.defineProperty(e, t, { enumerable: !1, configurable: !1, writable: !0, value: r }) } function f(e, t, r) { var n = { enumerable: !0, configurable: !0 }; "function" == typeof r ? n.get = r : (n.value = r, n.writable = !1), Object.defineProperty(e, t, n) } function g(e) { return !(!d(e) || e.attributes && !Array.isArray(e.attributes)) } "function" == typeof Object.assign && (c = Object.assign); var y, m = { exports: {} }, v = "object" == typeof Reflect ? Reflect : null, b = v && "function" == typeof v.apply ? v.apply : function (e, t, r) { return Function.prototype.apply.call(e, t, r) }; y = v && "function" == typeof v.ownKeys ? v.ownKeys : Object.getOwnPropertySymbols ? function (e) { return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)) } : function (e) { return Object.getOwnPropertyNames(e) }; var w = Number.isNaN || function (e) { return e != e }; function _() { _.init.call(this) } m.exports = _, m.exports.once = function (e, t) { return new Promise((function (r, n) { function i(r) { e.removeListener(t, o), n(r) } function o() { "function" == typeof e.removeListener && e.removeListener("error", i), r([].slice.call(arguments)) } O(e, t, o, { once: !0 }), "error" !== t && function (e, t, r) { "function" == typeof e.on && O(e, "error", t, { once: !0 }) }(e, i) })) }, _.EventEmitter = _, _.prototype._events = void 0, _.prototype._eventsCount = 0, _.prototype._maxListeners = void 0; var x = 10; function E(e) { if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e) } function C(e) { return void 0 === e._maxListeners ? _.defaultMaxListeners : e._maxListeners } function k(e, t, r, n) { var i, o, a, s; if (E(r), void 0 === (o = e._events) ? (o = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== o.newListener && (e.emit("newListener", t, r.listener ? r.listener : r), o = e._events), a = o[t]), void 0 === a) a = o[t] = r, ++e._eventsCount; else if ("function" == typeof a ? a = o[t] = n ? [r, a] : [a, r] : n ? a.unshift(r) : a.push(r), (i = C(e)) > 0 && a.length > i && !a.warned) { a.warned = !0; var c = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit"); c.name = "MaxListenersExceededWarning", c.emitter = e, c.type = t, c.count = a.length, s = c, console && console.warn && console.warn(s) } return e } function L() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function A(e, t, r) { var n = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, i = L.bind(n); return i.listener = r, n.wrapFn = i, i } function S(e, t, r) { var n = e._events; if (void 0 === n) return []; var i = n[t]; return void 0 === i ? [] : "function" == typeof i ? r ? [i.listener || i] : [i] : r ? function (e) { for (var t = new Array(e.length), r = 0; r < t.length; ++r)t[r] = e[r].listener || e[r]; return t }(i) : T(i, i.length) } function F(e) { var t = this._events; if (void 0 !== t) { var r = t[e]; if ("function" == typeof r) return 1; if (void 0 !== r) return r.length } return 0 } function T(e, t) { for (var r = new Array(t), n = 0; n < t; ++n)r[n] = e[n]; return r } function O(e, t, r, n) { if ("function" == typeof e.on) n.once ? e.once(t, r) : e.on(t, r); else { if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e); e.addEventListener(t, (function i(o) { n.once && e.removeEventListener(t, i), r(o) })) } } function P(e) { if ("function" != typeof e) throw new Error("obliterator/iterator: expecting a function!"); this.next = e } Object.defineProperty(_, "defaultMaxListeners", { enumerable: !0, get: function () { return x }, set: function (e) { if ("number" != typeof e || e < 0 || w(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + "."); x = e } }), _.init = function () { void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }, _.prototype.setMaxListeners = function (e) { if ("number" != typeof e || e < 0 || w(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + "."); return this._maxListeners = e, this }, _.prototype.getMaxListeners = function () { return C(this) }, _.prototype.emit = function (e) { for (var t = [], r = 1; r < arguments.length; r++)t.push(arguments[r]); var n = "error" === e, i = this._events; if (void 0 !== i) n = n && void 0 === i.error; else if (!n) return !1; if (n) { var o; if (t.length > 0 && (o = t[0]), o instanceof Error) throw o; var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : "")); throw a.context = o, a } var s = i[e]; if (void 0 === s) return !1; if ("function" == typeof s) b(s, this, t); else { var c = s.length, u = T(s, c); for (r = 0; r < c; ++r)b(u[r], this, t) } return !0 }, _.prototype.addListener = function (e, t) { return k(this, e, t, !1) }, _.prototype.on = _.prototype.addListener, _.prototype.prependListener = function (e, t) { return k(this, e, t, !0) }, _.prototype.once = function (e, t) { return E(t), this.on(e, A(this, e, t)), this }, _.prototype.prependOnceListener = function (e, t) { return E(t), this.prependListener(e, A(this, e, t)), this }, _.prototype.removeListener = function (e, t) { var r, n, i, o, a; if (E(t), void 0 === (n = this._events)) return this; if (void 0 === (r = n[e])) return this; if (r === t || r.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, r.listener || t)); else if ("function" != typeof r) { for (i = -1, o = r.length - 1; o >= 0; o--)if (r[o] === t || r[o].listener === t) { a = r[o].listener, i = o; break } if (i < 0) return this; 0 === i ? r.shift() : function (e, t) { for (; t + 1 < e.length; t++)e[t] = e[t + 1]; e.pop() }(r, i), 1 === r.length && (n[e] = r[0]), void 0 !== n.removeListener && this.emit("removeListener", e, a || t) } return this }, _.prototype.off = _.prototype.removeListener, _.prototype.removeAllListeners = function (e) { var t, r, n; if (void 0 === (r = this._events)) return this; if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[e]), this; if (0 === arguments.length) { var i, o = Object.keys(r); for (n = 0; n < o.length; ++n)"removeListener" !== (i = o[n]) && this.removeAllListeners(i); return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this } if ("function" == typeof (t = r[e])) this.removeListener(e, t); else if (void 0 !== t) for (n = t.length - 1; n >= 0; n--)this.removeListener(e, t[n]); return this }, _.prototype.listeners = function (e) { return S(this, e, !0) }, _.prototype.rawListeners = function (e) { return S(this, e, !1) }, _.listenerCount = function (e, t) { return "function" == typeof e.listenerCount ? e.listenerCount(t) : F.call(e, t) }, _.prototype.listenerCount = F, _.prototype.eventNames = function () { return this._eventsCount > 0 ? y(this._events) : [] }, "undefined" != typeof Symbol && (P.prototype[Symbol.iterator] = function () { return this }), P.of = function () { var e = arguments, t = e.length, r = 0; return new P((function () { return r >= t ? { done: !0 } : { done: !1, value: e[r++] } })) }, P.empty = function () { return new P((function () { return { done: !0 } })) }, P.fromSequence = function (e) { var t = 0, r = e.length; return new P((function () { return t >= r ? { done: !0 } : { done: !1, value: e[t++] } })) }, P.is = function (e) { return e instanceof P || "object" == typeof e && null !== e && "function" == typeof e.next }; var M = P, R = {}; R.ARRAY_BUFFER_SUPPORT = "undefined" != typeof ArrayBuffer, R.SYMBOL_SUPPORT = "undefined" != typeof Symbol; var D = M, G = R, N = G.ARRAY_BUFFER_SUPPORT, j = G.SYMBOL_SUPPORT, B = function (e) { var t = function (e) { return "string" == typeof e || Array.isArray(e) || N && ArrayBuffer.isView(e) ? D.fromSequence(e) : "object" != typeof e || null === e ? null : j && "function" == typeof e[Symbol.iterator] ? e[Symbol.iterator]() : "function" == typeof e.next ? e : null }(e); if (!t) throw new Error("obliterator: target is not iterable nor a valid iterator."); return t }, z = B, U = function (e, t) { for (var r, n = arguments.length > 1 ? t : 1 / 0, i = n !== 1 / 0 ? new Array(n) : [], o = 0, a = z(e); ;) { if (o === n) return i; if ((r = a.next()).done) return o !== t && (i.length = o), i; i[o++] = r.value } }, I = function (e) { function r(t) { var r; return (r = e.call(this) || this).name = "GraphError", r.message = t, r } return t(r, e), r }(a(Error)), W = function (e) { function r(t) { var n; return (n = e.call(this, t) || this).name = "InvalidArgumentsGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(s(n), r.prototype.constructor), n } return t(r, e), r }(I), q = function (e) { function r(t) { var n; return (n = e.call(this, t) || this).name = "NotFoundGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(s(n), r.prototype.constructor), n } return t(r, e), r }(I), H = function (e) { function r(t) { var n; return (n = e.call(this, t) || this).name = "UsageGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(s(n), r.prototype.constructor), n } return t(r, e), r }(I); function Y(e, t) { this.key = e, this.attributes = t, this.clear() } function V(e, t) { this.key = e, this.attributes = t, this.clear() } function K(e, t) { this.key = e, this.attributes = t, this.clear() } function Z(e, t, r, n, i) { this.key = t, this.attributes = i, this.undirected = e, this.source = r, this.target = n } function X(e, t, r, n, i, o, a) { var s, c, u, h; if (n = "" + n, 0 === r) { if (!(s = e._nodes.get(n))) throw new q("Graph.".concat(t, ': could not find the "').concat(n, '" node in the graph.')); u = i, h = o } else if (3 === r) { if (i = "" + i, !(c = e._edges.get(i))) throw new q("Graph.".concat(t, ': could not find the "').concat(i, '" edge in the graph.')); var d = c.source.key, l = c.target.key; if (n === d) s = c.target; else { if (n !== l) throw new q("Graph.".concat(t, ': the "').concat(n, '" node is not attached to the "').concat(i, '" edge (').concat(d, ", ").concat(l, ").")); s = c.source } u = o, h = a } else { if (!(c = e._edges.get(n))) throw new q("Graph.".concat(t, ': could not find the "').concat(n, '" edge in the graph.')); s = 1 === r ? c.source : c.target, u = i, h = o } return [s, u, h] } Y.prototype.clear = function () { this.inDegree = 0, this.outDegree = 0, this.undirectedDegree = 0, this.in = {}, this.out = {}, this.undirected = {} }, V.prototype.clear = function () { this.inDegree = 0, this.outDegree = 0, this.in = {}, this.out = {} }, K.prototype.clear = function () { this.undirectedDegree = 0, this.undirected = {} }, Z.prototype.attach = function () { var e = "out", t = "in"; this.undirected && (e = t = "undirected"); var r = this.source.key, n = this.target.key; this.source[e][n] = this, this.undirected && r === n || (this.target[t][r] = this) }, Z.prototype.attachMulti = function () { var e = "out", t = "in", r = this.source.key, n = this.target.key; this.undirected && (e = t = "undirected"); var i = this.source[e], o = i[n]; if (void 0 === o) return i[n] = this, void (this.undirected && r === n || (this.target[t][r] = this)); o.previous = this, this.next = o, i[n] = this, this.target[t][r] = this }, Z.prototype.detach = function () { var e = this.source.key, t = this.target.key, r = "out", n = "in"; this.undirected && (r = n = "undirected"), delete this.source[r][t], delete this.target[n][e] }, Z.prototype.detachMulti = function () { var e = this.source.key, t = this.target.key, r = "out", n = "in"; this.undirected && (r = n = "undirected"), void 0 === this.previous ? void 0 === this.next ? (delete this.source[r][t], delete this.target[n][e]) : (this.next.previous = void 0, this.source[r][t] = this.next, this.target[n][e] = this.next) : (this.previous.next = this.next, void 0 !== this.next && (this.next.previous = this.previous)) }; var $ = [{ name: function (e) { return "get".concat(e, "Attribute") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n, i) { var o = X(this, t, r, e, n, i), a = o[0], s = o[1]; return a.attributes[s] } } }, { name: function (e) { return "get".concat(e, "Attributes") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n) { return X(this, t, r, e, n)[0].attributes } } }, { name: function (e) { return "has".concat(e, "Attribute") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n, i) { var o = X(this, t, r, e, n, i), a = o[0], s = o[1]; return a.attributes.hasOwnProperty(s) } } }, { name: function (e) { return "set".concat(e, "Attribute") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n, i, o) { var a = X(this, t, r, e, n, i, o), s = a[0], c = a[1], u = a[2]; return s.attributes[c] = u, this.emit("nodeAttributesUpdated", { key: s.key, type: "set", attributes: s.attributes, name: c }), this } } }, { name: function (e) { return "update".concat(e, "Attribute") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n, i, o) { var a = X(this, t, r, e, n, i, o), s = a[0], c = a[1], u = a[2]; if ("function" != typeof u) throw new W("Graph.".concat(t, ": updater should be a function.")); var h = s.attributes, d = u(h[c]); return h[c] = d, this.emit("nodeAttributesUpdated", { key: s.key, type: "set", attributes: s.attributes, name: c }), this } } }, { name: function (e) { return "remove".concat(e, "Attribute") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n, i) { var o = X(this, t, r, e, n, i), a = o[0], s = o[1]; return delete a.attributes[s], this.emit("nodeAttributesUpdated", { key: a.key, type: "remove", attributes: a.attributes, name: s }), this } } }, { name: function (e) { return "replace".concat(e, "Attributes") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n, i) { var o = X(this, t, r, e, n, i), a = o[0], s = o[1]; if (!d(s)) throw new W("Graph.".concat(t, ": provided attributes are not a plain object.")); return a.attributes = s, this.emit("nodeAttributesUpdated", { key: a.key, type: "replace", attributes: a.attributes }), this } } }, { name: function (e) { return "merge".concat(e, "Attributes") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n, i) { var o = X(this, t, r, e, n, i), a = o[0], s = o[1]; if (!d(s)) throw new W("Graph.".concat(t, ": provided attributes are not a plain object.")); return c(a.attributes, s), this.emit("nodeAttributesUpdated", { key: a.key, type: "merge", attributes: a.attributes, data: s }), this } } }, { name: function (e) { return "update".concat(e, "Attributes") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n, i) { var o = X(this, t, r, e, n, i), a = o[0], s = o[1]; if ("function" != typeof s) throw new W("Graph.".concat(t, ": provided updater is not a function.")); return a.attributes = s(a.attributes), this.emit("nodeAttributesUpdated", { key: a.key, type: "update", attributes: a.attributes }), this } } }], J = [{ name: function (e) { return "get".concat(e, "Attribute") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n) { var i; if ("mixed" !== this.type && "mixed" !== r && r !== this.type) throw new H("Graph.".concat(t, ": cannot find this type of edges in your ").concat(this.type, " graph.")); if (arguments.length > 2) { if (this.multi) throw new H("Graph.".concat(t, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.")); var o = "" + e, a = "" + n; if (n = arguments[2], !(i = u(this, o, a, r))) throw new q("Graph.".concat(t, ': could not find an edge for the given path ("').concat(o, '" - "').concat(a, '").')) } else { if ("mixed" !== r) throw new H("Graph.".concat(t, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.")); if (e = "" + e, !(i = this._edges.get(e))) throw new q("Graph.".concat(t, ': could not find the "').concat(e, '" edge in the graph.')) } return i.attributes[n] } } }, { name: function (e) { return "get".concat(e, "Attributes") }, attacher: function (e, t, r) { e.prototype[t] = function (e) { var n; if ("mixed" !== this.type && "mixed" !== r && r !== this.type) throw new H("Graph.".concat(t, ": cannot find this type of edges in your ").concat(this.type, " graph.")); if (arguments.length > 1) { if (this.multi) throw new H("Graph.".concat(t, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.")); var i = "" + e, o = "" + arguments[1]; if (!(n = u(this, i, o, r))) throw new q("Graph.".concat(t, ': could not find an edge for the given path ("').concat(i, '" - "').concat(o, '").')) } else { if ("mixed" !== r) throw new H("Graph.".concat(t, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.")); if (e = "" + e, !(n = this._edges.get(e))) throw new q("Graph.".concat(t, ': could not find the "').concat(e, '" edge in the graph.')) } return n.attributes } } }, { name: function (e) { return "has".concat(e, "Attribute") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n) { var i; if ("mixed" !== this.type && "mixed" !== r && r !== this.type) throw new H("Graph.".concat(t, ": cannot find this type of edges in your ").concat(this.type, " graph.")); if (arguments.length > 2) { if (this.multi) throw new H("Graph.".concat(t, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.")); var o = "" + e, a = "" + n; if (n = arguments[2], !(i = u(this, o, a, r))) throw new q("Graph.".concat(t, ': could not find an edge for the given path ("').concat(o, '" - "').concat(a, '").')) } else { if ("mixed" !== r) throw new H("Graph.".concat(t, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.")); if (e = "" + e, !(i = this._edges.get(e))) throw new q("Graph.".concat(t, ': could not find the "').concat(e, '" edge in the graph.')) } return i.attributes.hasOwnProperty(n) } } }, { name: function (e) { return "set".concat(e, "Attribute") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n, i) { var o; if ("mixed" !== this.type && "mixed" !== r && r !== this.type) throw new H("Graph.".concat(t, ": cannot find this type of edges in your ").concat(this.type, " graph.")); if (arguments.length > 3) { if (this.multi) throw new H("Graph.".concat(t, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.")); var a = "" + e, s = "" + n; if (n = arguments[2], i = arguments[3], !(o = u(this, a, s, r))) throw new q("Graph.".concat(t, ': could not find an edge for the given path ("').concat(a, '" - "').concat(s, '").')) } else { if ("mixed" !== r) throw new H("Graph.".concat(t, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.")); if (e = "" + e, !(o = this._edges.get(e))) throw new q("Graph.".concat(t, ': could not find the "').concat(e, '" edge in the graph.')) } return o.attributes[n] = i, this.emit("edgeAttributesUpdated", { key: o.key, type: "set", attributes: o.attributes, name: n }), this } } }, { name: function (e) { return "update".concat(e, "Attribute") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n, i) { var o; if ("mixed" !== this.type && "mixed" !== r && r !== this.type) throw new H("Graph.".concat(t, ": cannot find this type of edges in your ").concat(this.type, " graph.")); if (arguments.length > 3) { if (this.multi) throw new H("Graph.".concat(t, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.")); var a = "" + e, s = "" + n; if (n = arguments[2], i = arguments[3], !(o = u(this, a, s, r))) throw new q("Graph.".concat(t, ': could not find an edge for the given path ("').concat(a, '" - "').concat(s, '").')) } else { if ("mixed" !== r) throw new H("Graph.".concat(t, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.")); if (e = "" + e, !(o = this._edges.get(e))) throw new q("Graph.".concat(t, ': could not find the "').concat(e, '" edge in the graph.')) } if ("function" != typeof i) throw new W("Graph.".concat(t, ": updater should be a function.")); return o.attributes[n] = i(o.attributes[n]), this.emit("edgeAttributesUpdated", { key: o.key, type: "set", attributes: o.attributes, name: n }), this } } }, { name: function (e) { return "remove".concat(e, "Attribute") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n) { var i; if ("mixed" !== this.type && "mixed" !== r && r !== this.type) throw new H("Graph.".concat(t, ": cannot find this type of edges in your ").concat(this.type, " graph.")); if (arguments.length > 2) { if (this.multi) throw new H("Graph.".concat(t, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.")); var o = "" + e, a = "" + n; if (n = arguments[2], !(i = u(this, o, a, r))) throw new q("Graph.".concat(t, ': could not find an edge for the given path ("').concat(o, '" - "').concat(a, '").')) } else { if ("mixed" !== r) throw new H("Graph.".concat(t, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.")); if (e = "" + e, !(i = this._edges.get(e))) throw new q("Graph.".concat(t, ': could not find the "').concat(e, '" edge in the graph.')) } return delete i.attributes[n], this.emit("edgeAttributesUpdated", { key: i.key, type: "remove", attributes: i.attributes, name: n }), this } } }, { name: function (e) { return "replace".concat(e, "Attributes") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n) { var i; if ("mixed" !== this.type && "mixed" !== r && r !== this.type) throw new H("Graph.".concat(t, ": cannot find this type of edges in your ").concat(this.type, " graph.")); if (arguments.length > 2) { if (this.multi) throw new H("Graph.".concat(t, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.")); var o = "" + e, a = "" + n; if (n = arguments[2], !(i = u(this, o, a, r))) throw new q("Graph.".concat(t, ': could not find an edge for the given path ("').concat(o, '" - "').concat(a, '").')) } else { if ("mixed" !== r) throw new H("Graph.".concat(t, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.")); if (e = "" + e, !(i = this._edges.get(e))) throw new q("Graph.".concat(t, ': could not find the "').concat(e, '" edge in the graph.')) } if (!d(n)) throw new W("Graph.".concat(t, ": provided attributes are not a plain object.")); return i.attributes = n, this.emit("edgeAttributesUpdated", { key: i.key, type: "replace", attributes: i.attributes }), this } } }, { name: function (e) { return "merge".concat(e, "Attributes") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n) { var i; if ("mixed" !== this.type && "mixed" !== r && r !== this.type) throw new H("Graph.".concat(t, ": cannot find this type of edges in your ").concat(this.type, " graph.")); if (arguments.length > 2) { if (this.multi) throw new H("Graph.".concat(t, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.")); var o = "" + e, a = "" + n; if (n = arguments[2], !(i = u(this, o, a, r))) throw new q("Graph.".concat(t, ': could not find an edge for the given path ("').concat(o, '" - "').concat(a, '").')) } else { if ("mixed" !== r) throw new H("Graph.".concat(t, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.")); if (e = "" + e, !(i = this._edges.get(e))) throw new q("Graph.".concat(t, ': could not find the "').concat(e, '" edge in the graph.')) } if (!d(n)) throw new W("Graph.".concat(t, ": provided attributes are not a plain object.")); return c(i.attributes, n), this.emit("edgeAttributesUpdated", { key: i.key, type: "merge", attributes: i.attributes, data: n }), this } } }, { name: function (e) { return "update".concat(e, "Attributes") }, attacher: function (e, t, r) { e.prototype[t] = function (e, n) { var i; if ("mixed" !== this.type && "mixed" !== r && r !== this.type) throw new H("Graph.".concat(t, ": cannot find this type of edges in your ").concat(this.type, " graph.")); if (arguments.length > 2) { if (this.multi) throw new H("Graph.".concat(t, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.")); var o = "" + e, a = "" + n; if (n = arguments[2], !(i = u(this, o, a, r))) throw new q("Graph.".concat(t, ': could not find an edge for the given path ("').concat(o, '" - "').concat(a, '").')) } else { if ("mixed" !== r) throw new H("Graph.".concat(t, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.")); if (e = "" + e, !(i = this._edges.get(e))) throw new q("Graph.".concat(t, ': could not find the "').concat(e, '" edge in the graph.')) } if ("function" != typeof n) throw new W("Graph.".concat(t, ": provided updater is not a function.")); return i.attributes = n(i.attributes), this.emit("edgeAttributesUpdated", { key: i.key, type: "update", attributes: i.attributes }), this } } }], Q = M, ee = B, te = function () { var e = arguments, t = null, r = -1; return new Q((function () { for (var n = null; ;) { if (null === t) { if (++r >= e.length) return { done: !0 }; t = ee(e[r]) } if (!0 !== (n = t.next()).done) break; t = null } return n })) }, re = [{ name: "edges", type: "mixed" }, { name: "inEdges", type: "directed", direction: "in" }, { name: "outEdges", type: "directed", direction: "out" }, { name: "inboundEdges", type: "mixed", direction: "in" }, { name: "outboundEdges", type: "mixed", direction: "out" }, { name: "directedEdges", type: "directed" }, { name: "undirectedEdges", type: "undirected" }]; function ne(e, t, r, n) { var i = !1; for (var o in t) if (o !== n) { var a = t[o]; if (i = r(a.key, a.attributes, a.source.key, a.target.key, a.source.attributes, a.target.attributes, a.undirected), e && i) return a.key } } function ie(e, t, r, n) { var i, o, a, s = !1; for (var c in t) if (c !== n) { i = t[c]; do { if (o = i.source, a = i.target, s = r(i.key, i.attributes, o.key, a.key, o.attributes, a.attributes, i.undirected), e && s) return i.key; i = i.next } while (void 0 !== i) } } function oe(e, t) { var r, n = Object.keys(e), i = n.length, o = 0; return new M((function () { do { if (r) r = r.next; else { if (o >= i) return { done: !0 }; var a = n[o++]; if (a === t) { r = void 0; continue } r = e[a] } } while (!r); return { done: !1, value: { edge: r.key, attributes: r.attributes, source: r.source.key, target: r.target.key, sourceAttributes: r.source.attributes, targetAttributes: r.target.attributes, undirected: r.undirected } } })) } function ae(e, t, r, n) { var i = t[r]; if (i) { var o = i.source, a = i.target; return n(i.key, i.attributes, o.key, a.key, o.attributes, a.attributes, i.undirected) && e ? i.key : void 0 } } function se(e, t, r, n) { var i = t[r]; if (i) { var o = !1; do { if (o = n(i.key, i.attributes, i.source.key, i.target.key, i.source.attributes, i.target.attributes, i.undirected), e && o) return i.key; i = i.next } while (void 0 !== i) } } function ce(e, t) { var r = e[t]; return void 0 !== r.next ? new M((function () { if (!r) return { done: !0 }; var e = { edge: r.key, attributes: r.attributes, source: r.source.key, target: r.target.key, sourceAttributes: r.source.attributes, targetAttributes: r.target.attributes, undirected: r.undirected }; return r = r.next, { done: !1, value: e } })) : M.of({ edge: r.key, attributes: r.attributes, source: r.source.key, target: r.target.key, sourceAttributes: r.source.attributes, targetAttributes: r.target.attributes, undirected: r.undirected }) } function ue(e, t) { if (0 === e.size) return []; if ("mixed" === t || t === e.type) return "function" == typeof Array.from ? Array.from(e._edges.keys()) : U(e._edges.keys(), e._edges.size); for (var r, n, i = "undirected" === t ? e.undirectedSize : e.directedSize, o = new Array(i), a = "undirected" === t, s = e._edges.values(), c = 0; !0 !== (r = s.next()).done;)(n = r.value).undirected === a && (o[c++] = n.key); return o } function he(e, t, r, n) { if (0 !== t.size) for (var i, o, a = "mixed" !== r && r !== t.type, s = "undirected" === r, c = !1, u = t._edges.values(); !0 !== (i = u.next()).done;)if (o = i.value, !a || o.undirected === s) { var h = o, d = h.key, l = h.attributes, p = h.source, f = h.target; if (c = n(d, l, p.key, f.key, p.attributes, f.attributes, o.undirected), e && c) return d } } function de(e, t) { if (0 === e.size) return M.empty(); var r = "mixed" !== t && t !== e.type, n = "undirected" === t, i = e._edges.values(); return new M((function () { for (var e, t; ;) { if ((e = i.next()).done) return e; if (t = e.value, !r || t.undirected === n) break } return { value: { edge: t.key, attributes: t.attributes, source: t.source.key, target: t.target.key, sourceAttributes: t.source.attributes, targetAttributes: t.target.attributes, undirected: t.undirected }, done: !1 } })) } function le(e, t, r, n, i, o) { var a, s = t ? ie : ne; if ("undirected" !== r) { if ("out" !== n && (a = s(e, i.in, o), e && a)) return a; if ("in" !== n && (a = s(e, i.out, o, n ? void 0 : i.key), e && a)) return a } if ("directed" !== r && (a = s(e, i.undirected, o), e && a)) return a } function pe(e, t, r, n) { var i = []; return le(!1, e, t, r, n, (function (e) { i.push(e) })), i } function fe(e, t, r) { var n = M.empty(); return "undirected" !== e && ("out" !== t && void 0 !== r.in && (n = te(n, oe(r.in))), "in" !== t && void 0 !== r.out && (n = te(n, oe(r.out, t ? void 0 : r.key)))), "directed" !== e && void 0 !== r.undirected && (n = te(n, oe(r.undirected))), n } function ge(e, t, r, n, i, o, a) { var s, c = r ? se : ae; if ("undirected" !== t) { if (void 0 !== i.in && "out" !== n && (s = c(e, i.in, o, a), e && s)) return s; if (void 0 !== i.out && "in" !== n && (n || i.key !== o) && (s = c(e, i.out, o, a), e && s)) return s } if ("directed" !== t && void 0 !== i.undirected && (s = c(e, i.undirected, o, a), e && s)) return s } function ye(e, t, r, n, i) { var o = []; return ge(!1, e, t, r, n, i, (function (e) { o.push(e) })), o } function me(e, t, r, n) { var i = M.empty(); return "undirected" !== e && (void 0 !== r.in && "out" !== t && n in r.in && (i = te(i, ce(r.in, n))), void 0 !== r.out && "in" !== t && n in r.out && (t || r.key !== n) && (i = te(i, ce(r.out, n)))), "directed" !== e && void 0 !== r.undirected && n in r.undirected && (i = te(i, ce(r.undirected, n))), i } var ve = [{ name: "neighbors", type: "mixed" }, { name: "inNeighbors", type: "directed", direction: "in" }, { name: "outNeighbors", type: "directed", direction: "out" }, { name: "inboundNeighbors", type: "mixed", direction: "in" }, { name: "outboundNeighbors", type: "mixed", direction: "out" }, { name: "directedNeighbors", type: "directed" }, { name: "undirectedNeighbors", type: "undirected" }]; function be() { this.A = null, this.B = null } function we(e, t, r, n, i) { for (var o in n) { var a = n[o], s = a.source, c = a.target, u = s === r ? c : s; if (!t || !t.has(u.key)) { var h = i(u.key, u.attributes); if (e && h) return u.key } } } function _e(e, t, r, n, i) { if ("mixed" !== t) { if ("undirected" === t) return we(e, null, n, n.undirected, i); if ("string" == typeof r) return we(e, null, n, n[r], i) } var o, a = new be; if ("undirected" !== t) { if ("out" !== r) { if (o = we(e, null, n, n.in, i), e && o) return o; a.wrap(n.in) } if ("in" !== r) { if (o = we(e, a, n, n.out, i), e && o) return o; a.wrap(n.out) } } if ("directed" !== t && (o = we(e, a, n, n.undirected, i), e && o)) return o } function xe(e, t, r) { var n = Object.keys(r), i = n.length, o = 0; return new M((function () { var a = null; do { if (o >= i) return e && e.wrap(r), { done: !0 }; var s = r[n[o++]], c = s.source, u = s.target; a = c === t ? u : c, e && e.has(a.key) && (a = null) } while (null === a); return { done: !1, value: { neighbor: a.key, attributes: a.attributes } } })) } function Ee(e, t, r, n, i) { for (var o, a, s, c, u, h, d, l = n._nodes.values(), p = n.type; !0 !== (o = l.next()).done;) { var f = !1; if (a = o.value, "undirected" !== p) for (s in c = a.out) { u = c[s]; do { if (h = u.target, f = !0, d = i(a.key, h.key, a.attributes, h.attributes, u.key, u.attributes, u.undirected), e && d) return u; u = u.next } while (u) } if ("directed" !== p) for (s in c = a.undirected) if (!(t && a.key > s)) { u = c[s]; do { if ((h = u.target).key !== s && (h = u.source), f = !0, d = i(a.key, h.key, a.attributes, h.attributes, u.key, u.attributes, u.undirected), e && d) return u; u = u.next } while (u) } if (r && !f && (d = i(a.key, null, a.attributes, null, null, null, null), e && d)) return null } } function Ce(e) { if (!d(e)) throw new W('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.'); if (!("key" in e)) throw new W("Graph.import: serialized node is missing its key."); if ("attributes" in e && (!d(e.attributes) || null === e.attributes)) throw new W("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.") } function ke(e) { if (!d(e)) throw new W('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.'); if (!("source" in e)) throw new W("Graph.import: serialized edge is missing its source."); if (!("target" in e)) throw new W("Graph.import: serialized edge is missing its target."); if ("attributes" in e && (!d(e.attributes) || null === e.attributes)) throw new W("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted."); if ("undirected" in e && "boolean" != typeof e.undirected) throw new W("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.") } be.prototype.wrap = function (e) { null === this.A ? this.A = e : null === this.B && (this.B = e) }, be.prototype.has = function (e) { return null !== this.A && e in this.A || null !== this.B && e in this.B }; var Le, Ae = (Le = 255 & Math.floor(256 * Math.random()), function () { return Le++ }), Se = new Set(["directed", "undirected", "mixed"]), Fe = new Set(["domain", "_events", "_eventsCount", "_maxListeners"]), Te = { allowSelfLoops: !0, multi: !1, type: "mixed" }; function Oe(e, t, r) { var n = new e.NodeDataClass(t, r); return e._nodes.set(t, n), e.emit("nodeAdded", { key: t, attributes: r }), n } function Pe(e, t, r, n, i, o, a, s) { if (!n && "undirected" === e.type) throw new H("Graph.".concat(t, ": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.")); if (n && "directed" === e.type) throw new H("Graph.".concat(t, ": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.")); if (s && !d(s)) throw new W("Graph.".concat(t, ': invalid attributes. Expecting an object but got "').concat(s, '"')); if (o = "" + o, a = "" + a, s = s || {}, !e.allowSelfLoops && o === a) throw new H("Graph.".concat(t, ': source & target are the same ("').concat(o, "\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.")); var c = e._nodes.get(o), u = e._nodes.get(a); if (!c) throw new q("Graph.".concat(t, ': source node "').concat(o, '" not found.')); if (!u) throw new q("Graph.".concat(t, ': target node "').concat(a, '" not found.')); var h = { key: null, undirected: n, source: o, target: a, attributes: s }; if (r) i = e._edgeKeyGenerator(); else if (i = "" + i, e._edges.has(i)) throw new H("Graph.".concat(t, ': the "').concat(i, '" edge already exists in the graph.')); if (!e.multi && (n ? void 0 !== c.undirected[a] : void 0 !== c.out[a])) throw new H("Graph.".concat(t, ': an edge linking "').concat(o, '" to "').concat(a, "\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.")); var l = new Z(n, i, c, u, s); e._edges.set(i, l); var p = o === a; return n ? (c.undirectedDegree++, u.undirectedDegree++, p && e._undirectedSelfLoopCount++) : (c.outDegree++, u.inDegree++, p && e._directedSelfLoopCount++), e.multi ? l.attachMulti() : l.attach(), n ? e._undirectedSize++ : e._directedSize++, h.key = i, e.emit("edgeAdded", h), i } function Me(e, t, r, n, i, o, a, s, u) { if (!n && "undirected" === e.type) throw new H("Graph.".concat(t, ": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.")); if (n && "directed" === e.type) throw new H("Graph.".concat(t, ": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.")); if (s) if (u) { if ("function" != typeof s) throw new W("Graph.".concat(t, ': invalid updater function. Expecting a function but got "').concat(s, '"')) } else if (!d(s)) throw new W("Graph.".concat(t, ': invalid attributes. Expecting an object but got "').concat(s, '"')); var h; if (o = "" + o, a = "" + a, u && (h = s, s = void 0), !e.allowSelfLoops && o === a) throw new H("Graph.".concat(t, ': source & target are the same ("').concat(o, "\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.")); var l, p, f = e._nodes.get(o), g = e._nodes.get(a); if (!r && (l = e._edges.get(i))) { if (!(l.source.key === o && l.target.key === a || n && l.source.key === a && l.target.key === o)) throw new H("Graph.".concat(t, ': inconsistency detected when attempting to merge the "').concat(i, '" edge with "').concat(o, '" source & "').concat(a, '" target vs. ("').concat(l.source.key, '", "').concat(l.target.key, '").')); p = l } if (p || e.multi || !f || (p = n ? f.undirected[a] : f.out[a]), p) { var y = [p.key, !1, !1, !1]; if (u ? !h : !s) return y; if (u) { var m = p.attributes; p.attributes = h(m), e.emit("edgeAttributesUpdated", { type: "replace", key: p.key, attributes: p.attributes }) } else c(p.attributes, s), e.emit("edgeAttributesUpdated", { type: "merge", key: p.key, attributes: p.attributes, data: s }); return y } s = s || {}, u && h && (s = h(s)); var v = { key: null, undirected: n, source: o, target: a, attributes: s }; if (r) i = e._edgeKeyGenerator(); else if (i = "" + i, e._edges.has(i)) throw new H("Graph.".concat(t, ': the "').concat(i, '" edge already exists in the graph.')); var b = !1, w = !1; f || (f = Oe(e, o, {}), b = !0, o === a && (g = f, w = !0)), g || (g = Oe(e, a, {}), w = !0), l = new Z(n, i, f, g, s), e._edges.set(i, l); var _ = o === a; return n ? (f.undirectedDegree++, g.undirectedDegree++, _ && e._undirectedSelfLoopCount++) : (f.outDegree++, g.inDegree++, _ && e._directedSelfLoopCount++), e.multi ? l.attachMulti() : l.attach(), n ? e._undirectedSize++ : e._directedSize++, v.key = i, e.emit("edgeAdded", v), [i, !0, b, w] } function Re(e, t) { e._edges.delete(t.key); var r = t.source, n = t.target, i = t.attributes, o = t.undirected, a = r === n; o ? (r.undirectedDegree--, n.undirectedDegree--, a && e._undirectedSelfLoopCount--) : (r.outDegree--, n.inDegree--, a && e._directedSelfLoopCount--), e.multi ? t.detachMulti() : t.detach(), o ? e._undirectedSize-- : e._directedSize--, e.emit("edgeDropped", { key: t.key, attributes: i, source: r.key, target: n.key, undirected: o }) } var De = function (r) { function n(e) { var t; if (t = r.call(this) || this, "boolean" != typeof (e = c({}, Te, e)).multi) throw new W("Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"".concat(e.multi, '".')); if (!Se.has(e.type)) throw new W('Graph.constructor: invalid \'type\' option. Should be one of "mixed", "directed" or "undirected" but got "'.concat(e.type, '".')); if ("boolean" != typeof e.allowSelfLoops) throw new W("Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"".concat(e.allowSelfLoops, '".')); var n = "mixed" === e.type ? Y : "directed" === e.type ? V : K; p(s(t), "NodeDataClass", n); var i = "geid_" + Ae() + "_", o = 0; return p(s(t), "_attributes", {}), p(s(t), "_nodes", new Map), p(s(t), "_edges", new Map), p(s(t), "_directedSize", 0), p(s(t), "_undirectedSize", 0), p(s(t), "_directedSelfLoopCount", 0), p(s(t), "_undirectedSelfLoopCount", 0), p(s(t), "_edgeKeyGenerator", (function () { var e; do { e = i + o++ } while (t._edges.has(e)); return e })), p(s(t), "_options", e), Fe.forEach((function (e) { return p(s(t), e, t[e]) })), f(s(t), "order", (function () { return t._nodes.size })), f(s(t), "size", (function () { return t._edges.size })), f(s(t), "directedSize", (function () { return t._directedSize })), f(s(t), "undirectedSize", (function () { return t._undirectedSize })), f(s(t), "selfLoopCount", (function () { return t._directedSelfLoopCount + t._undirectedSelfLoopCount })), f(s(t), "directedSelfLoopCount", (function () { return t._directedSelfLoopCount })), f(s(t), "undirectedSelfLoopCount", (function () { return t._undirectedSelfLoopCount })), f(s(t), "multi", t._options.multi), f(s(t), "type", t._options.type), f(s(t), "allowSelfLoops", t._options.allowSelfLoops), f(s(t), "implementation", (function () { return "graphology" })), t } t(n, r); var i = n.prototype; return i._resetInstanceCounters = function () { this._directedSize = 0, this._undirectedSize = 0, this._directedSelfLoopCount = 0, this._undirectedSelfLoopCount = 0 }, i.hasNode = function (e) { return this._nodes.has("" + e) }, i.hasDirectedEdge = function (e, t) { if ("undirected" === this.type) return !1; if (1 === arguments.length) { var r = "" + e, n = this._edges.get(r); return !!n && !n.undirected } if (2 === arguments.length) { e = "" + e, t = "" + t; var i = this._nodes.get(e); if (!i) return !1; var o = i.out[t]; return !(!o || this.multi && !o.size) } throw new W("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.")) }, i.hasUndirectedEdge = function (e, t) { if ("directed" === this.type) return !1; if (1 === arguments.length) { var r = "" + e, n = this._edges.get(r); return !!n && n.undirected } if (2 === arguments.length) { e = "" + e, t = "" + t; var i = this._nodes.get(e); if (!i) return !1; var o = i.undirected[t]; return !(!o || this.multi && !o.size) } throw new W("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.")) }, i.hasEdge = function (e, t) { if (1 === arguments.length) { var r = "" + e; return this._edges.has(r) } if (2 === arguments.length) { e = "" + e, t = "" + t; var n = this._nodes.get(e); if (!n) return !1; var i = void 0 !== n.out && n.out[t]; return i || (i = void 0 !== n.undirected && n.undirected[t]), !(!i || this.multi && !i.size) } throw new W("Graph.hasEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.")) }, i.directedEdge = function (e, t) { if ("undirected" !== this.type) { if (e = "" + e, t = "" + t, this.multi) throw new H("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead."); var r = this._nodes.get(e); if (!r) throw new q('Graph.directedEdge: could not find the "'.concat(e, '" source node in the graph.')); if (!this._nodes.has(t)) throw new q('Graph.directedEdge: could not find the "'.concat(t, '" target node in the graph.')); var n = r.out && r.out[t] || void 0; return n ? n.key : void 0 } }, i.undirectedEdge = function (e, t) { if ("directed" !== this.type) { if (e = "" + e, t = "" + t, this.multi) throw new H("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead."); var r = this._nodes.get(e); if (!r) throw new q('Graph.undirectedEdge: could not find the "'.concat(e, '" source node in the graph.')); if (!this._nodes.has(t)) throw new q('Graph.undirectedEdge: could not find the "'.concat(t, '" target node in the graph.')); var n = r.undirected && r.undirected[t] || void 0; return n ? n.key : void 0 } }, i.edge = function (e, t) { if (this.multi) throw new H("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead."); e = "" + e, t = "" + t; var r = this._nodes.get(e); if (!r) throw new q('Graph.edge: could not find the "'.concat(e, '" source node in the graph.')); if (!this._nodes.has(t)) throw new q('Graph.edge: could not find the "'.concat(t, '" target node in the graph.')); var n = r.out && r.out[t] || r.undirected && r.undirected[t] || void 0; if (n) return n.key }, i.areDirectedNeighbors = function (e, t) { e = "" + e, t = "" + t; var r = this._nodes.get(e); if (!r) throw new q('Graph.areDirectedNeighbors: could not find the "'.concat(e, '" node in the graph.')); return "undirected" !== this.type && (t in r.in || t in r.out) }, i.areOutNeighbors = function (e, t) { e = "" + e, t = "" + t; var r = this._nodes.get(e); if (!r) throw new q('Graph.areOutNeighbors: could not find the "'.concat(e, '" node in the graph.')); return "undirected" !== this.type && t in r.out }, i.areInNeighbors = function (e, t) { e = "" + e, t = "" + t; var r = this._nodes.get(e); if (!r) throw new q('Graph.areInNeighbors: could not find the "'.concat(e, '" node in the graph.')); return "undirected" !== this.type && t in r.in }, i.areUndirectedNeighbors = function (e, t) { e = "" + e, t = "" + t; var r = this._nodes.get(e); if (!r) throw new q('Graph.areUndirectedNeighbors: could not find the "'.concat(e, '" node in the graph.')); return "directed" !== this.type && t in r.undirected }, i.areNeighbors = function (e, t) { e = "" + e, t = "" + t; var r = this._nodes.get(e); if (!r) throw new q('Graph.areNeighbors: could not find the "'.concat(e, '" node in the graph.')); return "undirected" !== this.type && (t in r.in || t in r.out) || "directed" !== this.type && t in r.undirected }, i.areInboundNeighbors = function (e, t) { e = "" + e, t = "" + t; var r = this._nodes.get(e); if (!r) throw new q('Graph.areInboundNeighbors: could not find the "'.concat(e, '" node in the graph.')); return "undirected" !== this.type && t in r.in || "directed" !== this.type && t in r.undirected }, i.areOutboundNeighbors = function (e, t) { e = "" + e, t = "" + t; var r = this._nodes.get(e); if (!r) throw new q('Graph.areOutboundNeighbors: could not find the "'.concat(e, '" node in the graph.')); return "undirected" !== this.type && t in r.out || "directed" !== this.type && t in r.undirected }, i.inDegree = function (e) { e = "" + e; var t = this._nodes.get(e); if (!t) throw new q('Graph.inDegree: could not find the "'.concat(e, '" node in the graph.')); return "undirected" === this.type ? 0 : t.inDegree }, i.outDegree = function (e) { e = "" + e; var t = this._nodes.get(e); if (!t) throw new q('Graph.outDegree: could not find the "'.concat(e, '" node in the graph.')); return "undirected" === this.type ? 0 : t.outDegree }, i.directedDegree = function (e) { e = "" + e; var t = this._nodes.get(e); if (!t) throw new q('Graph.directedDegree: could not find the "'.concat(e, '" node in the graph.')); return "undirected" === this.type ? 0 : t.inDegree + t.outDegree }, i.undirectedDegree = function (e) { e = "" + e; var t = this._nodes.get(e); if (!t) throw new q('Graph.undirectedDegree: could not find the "'.concat(e, '" node in the graph.')); return "directed" === this.type ? 0 : t.undirectedDegree }, i.inboundDegree = function (e) { e = "" + e; var t = this._nodes.get(e); if (!t) throw new q('Graph.inboundDegree: could not find the "'.concat(e, '" node in the graph.')); var r = 0; return "directed" !== this.type && (r += t.undirectedDegree), "undirected" !== this.type && (r += t.inDegree), r }, i.outboundDegree = function (e) { e = "" + e; var t = this._nodes.get(e); if (!t) throw new q('Graph.outboundDegree: could not find the "'.concat(e, '" node in the graph.')); var r = 0; return "directed" !== this.type && (r += t.undirectedDegree), "undirected" !== this.type && (r += t.outDegree), r }, i.degree = function (e) { e = "" + e; var t = this._nodes.get(e); if (!t) throw new q('Graph.degree: could not find the "'.concat(e, '" node in the graph.')); var r = 0; return "directed" !== this.type && (r += t.undirectedDegree), "undirected" !== this.type && (r += t.inDegree + t.outDegree), r }, i.inDegreeWithoutSelfLoops = function (e) { e = "" + e; var t = this._nodes.get(e); if (!t) throw new q('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(e, '" node in the graph.')); if ("undirected" === this.type) return 0; var r = t.in[e], n = r ? this.multi ? r.size : 1 : 0; return t.inDegree - n }, i.outDegreeWithoutSelfLoops = function (e) { e = "" + e; var t = this._nodes.get(e); if (!t) throw new q('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(e, '" node in the graph.')); if ("undirected" === this.type) return 0; var r = t.out[e], n = r ? this.multi ? r.size : 1 : 0; return t.outDegree - n }, i.directedDegreeWithoutSelfLoops = function (e) { e = "" + e; var t = this._nodes.get(e); if (!t) throw new q('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(e, '" node in the graph.')); if ("undirected" === this.type) return 0; var r = t.out[e], n = r ? this.multi ? r.size : 1 : 0; return t.inDegree + t.outDegree - 2 * n }, i.undirectedDegreeWithoutSelfLoops = function (e) { e = "" + e; var t = this._nodes.get(e); if (!t) throw new q('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(e, '" node in the graph.')); if ("directed" === this.type) return 0; var r = t.undirected[e], n = r ? this.multi ? r.size : 1 : 0; return t.undirectedDegree - 2 * n }, i.inboundDegreeWithoutSelfLoops = function (e) { e = "" + e; var t, r = this._nodes.get(e); if (!r) throw new q('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(e, '" node in the graph.')); var n = 0, i = 0; return "directed" !== this.type && (n += r.undirectedDegree, i += 2 * ((t = r.undirected[e]) ? this.multi ? t.size : 1 : 0)), "undirected" !== this.type && (n += r.inDegree, i += (t = r.out[e]) ? this.multi ? t.size : 1 : 0), n - i }, i.outboundDegreeWithoutSelfLoops = function (e) { e = "" + e; var t, r = this._nodes.get(e); if (!r) throw new q('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(e, '" node in the graph.')); var n = 0, i = 0; return "directed" !== this.type && (n += r.undirectedDegree, i += 2 * ((t = r.undirected[e]) ? this.multi ? t.size : 1 : 0)), "undirected" !== this.type && (n += r.outDegree, i += (t = r.in[e]) ? this.multi ? t.size : 1 : 0), n - i }, i.degreeWithoutSelfLoops = function (e) { e = "" + e; var t, r = this._nodes.get(e); if (!r) throw new q('Graph.degreeWithoutSelfLoops: could not find the "'.concat(e, '" node in the graph.')); var n = 0, i = 0; return "directed" !== this.type && (n += r.undirectedDegree, i += 2 * ((t = r.undirected[e]) ? this.multi ? t.size : 1 : 0)), "undirected" !== this.type && (n += r.inDegree + r.outDegree, i += 2 * ((t = r.out[e]) ? this.multi ? t.size : 1 : 0)), n - i }, i.source = function (e) { e = "" + e; var t = this._edges.get(e); if (!t) throw new q('Graph.source: could not find the "'.concat(e, '" edge in the graph.')); return t.source.key }, i.target = function (e) { e = "" + e; var t = this._edges.get(e); if (!t) throw new q('Graph.target: could not find the "'.concat(e, '" edge in the graph.')); return t.target.key }, i.extremities = function (e) { e = "" + e; var t = this._edges.get(e); if (!t) throw new q('Graph.extremities: could not find the "'.concat(e, '" edge in the graph.')); return [t.source.key, t.target.key] }, i.opposite = function (e, t) { e = "" + e, t = "" + t; var r = this._edges.get(t); if (!r) throw new q('Graph.opposite: could not find the "'.concat(t, '" edge in the graph.')); var n = r.source.key, i = r.target.key; if (e === n) return i; if (e === i) return n; throw new q('Graph.opposite: the "'.concat(e, '" node is not attached to the "').concat(t, '" edge (').concat(n, ", ").concat(i, ").")) }, i.hasExtremity = function (e, t) { e = "" + e, t = "" + t; var r = this._edges.get(e); if (!r) throw new q('Graph.hasExtremity: could not find the "'.concat(e, '" edge in the graph.')); return r.source.key === t || r.target.key === t }, i.isUndirected = function (e) { e = "" + e; var t = this._edges.get(e); if (!t) throw new q('Graph.isUndirected: could not find the "'.concat(e, '" edge in the graph.')); return t.undirected }, i.isDirected = function (e) { e = "" + e; var t = this._edges.get(e); if (!t) throw new q('Graph.isDirected: could not find the "'.concat(e, '" edge in the graph.')); return !t.undirected }, i.isSelfLoop = function (e) { e = "" + e; var t = this._edges.get(e); if (!t) throw new q('Graph.isSelfLoop: could not find the "'.concat(e, '" edge in the graph.')); return t.source === t.target }, i.addNode = function (e, t) { var r = function (e, t, r) { if (r && !d(r)) throw new W('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(r, '"')); if (t = "" + t, r = r || {}, e._nodes.has(t)) throw new H('Graph.addNode: the "'.concat(t, '" node already exist in the graph.')); var n = new e.NodeDataClass(t, r); return e._nodes.set(t, n), e.emit("nodeAdded", { key: t, attributes: r }), n }(this, e, t); return r.key }, i.mergeNode = function (e, t) { if (t && !d(t)) throw new W('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(t, '"')); e = "" + e, t = t || {}; var r = this._nodes.get(e); return r ? (t && (c(r.attributes, t), this.emit("nodeAttributesUpdated", { type: "merge", key: e, attributes: r.attributes, data: t })), [e, !1]) : (r = new this.NodeDataClass(e, t), this._nodes.set(e, r), this.emit("nodeAdded", { key: e, attributes: t }), [e, !0]) }, i.updateNode = function (e, t) { if (t && "function" != typeof t) throw new W('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(t, '"')); e = "" + e; var r = this._nodes.get(e); if (r) { if (t) { var n = r.attributes; r.attributes = t(n), this.emit("nodeAttributesUpdated", { type: "replace", key: e, attributes: r.attributes }) } return [e, !1] } var i = t ? t({}) : {}; return r = new this.NodeDataClass(e, i), this._nodes.set(e, r), this.emit("nodeAdded", { key: e, attributes: i }), [e, !0] }, i.dropNode = function (e) { e = "" + e; var t, r = this._nodes.get(e); if (!r) throw new q('Graph.dropNode: could not find the "'.concat(e, '" node in the graph.')); if ("undirected" !== this.type) { for (var n in r.out) { t = r.out[n]; do { Re(this, t), t = t.next } while (t) } for (var i in r.in) { t = r.in[i]; do { Re(this, t), t = t.next } while (t) } } if ("directed" !== this.type) for (var o in r.undirected) { t = r.undirected[o]; do { Re(this, t), t = t.next } while (t) } this._nodes.delete(e), this.emit("nodeDropped", { key: e, attributes: r.attributes }) }, i.dropEdge = function (e) { var t; if (arguments.length > 1) { var r = "" + arguments[0], n = "" + arguments[1]; if (!(t = u(this, r, n, this.type))) throw new q('Graph.dropEdge: could not find the "'.concat(r, '" -> "').concat(n, '" edge in the graph.')) } else if (e = "" + e, !(t = this._edges.get(e))) throw new q('Graph.dropEdge: could not find the "'.concat(e, '" edge in the graph.')); return Re(this, t), this }, i.dropDirectedEdge = function (e, t) { if (arguments.length < 2) throw new H("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead."); if (this.multi) throw new H("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones."); var r = u(this, e = "" + e, t = "" + t, "directed"); if (!r) throw new q('Graph.dropDirectedEdge: could not find a "'.concat(e, '" -> "').concat(t, '" edge in the graph.')); return Re(this, r), this }, i.dropUndirectedEdge = function (e, t) { if (arguments.length < 2) throw new H("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead."); if (this.multi) throw new H("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones."); var r = u(this, e, t, "undirected"); if (!r) throw new q('Graph.dropUndirectedEdge: could not find a "'.concat(e, '" -> "').concat(t, '" edge in the graph.')); return Re(this, r), this }, i.clear = function () { this._edges.clear(), this._nodes.clear(), this._resetInstanceCounters(), this.emit("cleared") }, i.clearEdges = function () { for (var e, t = this._nodes.values(); !0 !== (e = t.next()).done;)e.value.clear(); this._edges.clear(), this._resetInstanceCounters(), this.emit("edgesCleared") }, i.getAttribute = function (e) { return this._attributes[e] }, i.getAttributes = function () { return this._attributes }, i.hasAttribute = function (e) { return this._attributes.hasOwnProperty(e) }, i.setAttribute = function (e, t) { return this._attributes[e] = t, this.emit("attributesUpdated", { type: "set", attributes: this._attributes, name: e }), this }, i.updateAttribute = function (e, t) { if ("function" != typeof t) throw new W("Graph.updateAttribute: updater should be a function."); var r = this._attributes[e]; return this._attributes[e] = t(r), this.emit("attributesUpdated", { type: "set", attributes: this._attributes, name: e }), this }, i.removeAttribute = function (e) { return delete this._attributes[e], this.emit("attributesUpdated", { type: "remove", attributes: this._attributes, name: e }), this }, i.replaceAttributes = function (e) { if (!d(e)) throw new W("Graph.replaceAttributes: provided attributes are not a plain object."); return this._attributes = e, this.emit("attributesUpdated", { type: "replace", attributes: this._attributes }), this }, i.mergeAttributes = function (e) { if (!d(e)) throw new W("Graph.mergeAttributes: provided attributes are not a plain object."); return c(this._attributes, e), this.emit("attributesUpdated", { type: "merge", attributes: this._attributes, data: e }), this }, i.updateAttributes = function (e) { if ("function" != typeof e) throw new W("Graph.updateAttributes: provided updater is not a function."); return this._attributes = e(this._attributes), this.emit("attributesUpdated", { type: "update", attributes: this._attributes }), this }, i.updateEachNodeAttributes = function (e, t) { if ("function" != typeof e) throw new W("Graph.updateEachNodeAttributes: expecting an updater function."); if (t && !g(t)) throw new W("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}"); for (var r, n, i = this._nodes.values(); !0 !== (r = i.next()).done;)(n = r.value).attributes = e(n.key, n.attributes); this.emit("eachNodeAttributesUpdated", { hints: t || null }) }, i.updateEachEdgeAttributes = function (e, t) { if ("function" != typeof e) throw new W("Graph.updateEachEdgeAttributes: expecting an updater function."); if (t && !g(t)) throw new W("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}"); for (var r, n, i, o, a = this._edges.values(); !0 !== (r = a.next()).done;)i = (n = r.value).source, o = n.target, n.attributes = e(n.key, n.attributes, i.key, o.key, i.attributes, o.attributes, n.undirected); this.emit("eachEdgeAttributesUpdated", { hints: t || null }) }, i.forEachAdjacencyEntry = function (e) { if ("function" != typeof e) throw new W("Graph.forEachAdjacencyEntry: expecting a callback."); Ee(!1, !1, !1, this, e) }, i.forEachAdjacencyEntryWithOrphans = function (e) { if ("function" != typeof e) throw new W("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback."); Ee(!1, !1, !0, this, e) }, i.forEachAssymetricAdjacencyEntry = function (e) { if ("function" != typeof e) throw new W("Graph.forEachAssymetricAdjacencyEntry: expecting a callback."); Ee(!1, !0, !1, this, e) }, i.forEachAssymetricAdjacencyEntryWithOrphans = function (e) { if ("function" != typeof e) throw new W("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback."); Ee(!1, !0, !0, this, e) }, i.nodes = function () { return "function" == typeof Array.from ? Array.from(this._nodes.keys()) : U(this._nodes.keys(), this._nodes.size) }, i.forEachNode = function (e) { if ("function" != typeof e) throw new W("Graph.forEachNode: expecting a callback."); for (var t, r, n = this._nodes.values(); !0 !== (t = n.next()).done;)e((r = t.value).key, r.attributes) }, i.findNode = function (e) { if ("function" != typeof e) throw new W("Graph.findNode: expecting a callback."); for (var t, r, n = this._nodes.values(); !0 !== (t = n.next()).done;)if (e((r = t.value).key, r.attributes)) return r.key }, i.mapNodes = function (e) { if ("function" != typeof e) throw new W("Graph.mapNode: expecting a callback."); for (var t, r, n = this._nodes.values(), i = new Array(this.order), o = 0; !0 !== (t = n.next()).done;)r = t.value, i[o++] = e(r.key, r.attributes); return i }, i.someNode = function (e) { if ("function" != typeof e) throw new W("Graph.someNode: expecting a callback."); for (var t, r, n = this._nodes.values(); !0 !== (t = n.next()).done;)if (e((r = t.value).key, r.attributes)) return !0; return !1 }, i.everyNode = function (e) { if ("function" != typeof e) throw new W("Graph.everyNode: expecting a callback."); for (var t, r, n = this._nodes.values(); !0 !== (t = n.next()).done;)if (!e((r = t.value).key, r.attributes)) return !1; return !0 }, i.filterNodes = function (e) { if ("function" != typeof e) throw new W("Graph.filterNodes: expecting a callback."); for (var t, r, n = this._nodes.values(), i = []; !0 !== (t = n.next()).done;)e((r = t.value).key, r.attributes) && i.push(r.key); return i }, i.reduceNodes = function (e, t) { if ("function" != typeof e) throw new W("Graph.reduceNodes: expecting a callback."); if (arguments.length < 2) throw new W("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."); for (var r, n, i = t, o = this._nodes.values(); !0 !== (r = o.next()).done;)i = e(i, (n = r.value).key, n.attributes); return i }, i.nodeEntries = function () { var e = this._nodes.values(); return new M((function () { var t = e.next(); if (t.done) return t; var r = t.value; return { value: { node: r.key, attributes: r.attributes }, done: !1 } })) }, i.export = function () { var e = new Array(this._nodes.size), t = 0; this._nodes.forEach((function (r, n) { e[t++] = function (e, t) { var r = { key: e }; return l(t.attributes) || (r.attributes = c({}, t.attributes)), r }(n, r) })); var r = new Array(this._edges.size); return t = 0, this._edges.forEach((function (e, n) { r[t++] = function (e, t) { var r = { key: e, source: t.source.key, target: t.target.key }; return l(t.attributes) || (r.attributes = c({}, t.attributes)), t.undirected && (r.undirected = !0), r }(n, e) })), { options: { type: this.type, multi: this.multi, allowSelfLoops: this.allowSelfLoops }, attributes: this.getAttributes(), nodes: e, edges: r } }, i.import = function (e) { var t, r, n, i, o, a = this, s = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (h(e)) return e.forEachNode((function (e, t) { s ? a.mergeNode(e, t) : a.addNode(e, t) })), e.forEachEdge((function (e, t, r, n, i, o, c) { s ? c ? a.mergeUndirectedEdgeWithKey(e, r, n, t) : a.mergeDirectedEdgeWithKey(e, r, n, t) : c ? a.addUndirectedEdgeWithKey(e, r, n, t) : a.addDirectedEdgeWithKey(e, r, n, t) })), this; if (!d(e)) throw new W("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance."); if (e.attributes) { if (!d(e.attributes)) throw new W("Graph.import: invalid attributes. Expecting a plain object."); s ? this.mergeAttributes(e.attributes) : this.replaceAttributes(e.attributes) } if (e.nodes) { if (n = e.nodes, !Array.isArray(n)) throw new W("Graph.import: invalid nodes. Expecting an array."); for (t = 0, r = n.length; t < r; t++) { Ce(i = n[t]); var c = i, u = c.key, l = c.attributes; s ? this.mergeNode(u, l) : this.addNode(u, l) } } if (e.edges) { if (n = e.edges, !Array.isArray(n)) throw new W("Graph.import: invalid edges. Expecting an array."); for (t = 0, r = n.length; t < r; t++) { ke(o = n[t]); var p = o, f = p.source, g = p.target, y = p.attributes, m = p.undirected, v = void 0 !== m && m; "key" in o ? (s ? v ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : v ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey).call(this, o.key, f, g, y) : (s ? v ? this.mergeUndirectedEdge : this.mergeDirectedEdge : v ? this.addUndirectedEdge : this.addDirectedEdge).call(this, f, g, y) } } return this }, i.nullCopy = function (e) { var t = new n(c({}, this._options, e)); return t.replaceAttributes(c({}, this.getAttributes())), t }, i.emptyCopy = function (e) { var t = this.nullCopy(e); return this._nodes.forEach((function (e, r) { var n = c({}, e.attributes); e = new t.NodeDataClass(r, n), t._nodes.set(r, e) })), t }, i.copy = function (e) { if ("string" == typeof (e = e || {}).type && e.type !== this.type && "mixed" !== e.type) throw new H('Graph.copy: cannot create an incompatible copy from "'.concat(this.type, '" type to "').concat(e.type, '" because this would mean losing information about the current graph.')); if ("boolean" == typeof e.multi && e.multi !== this.multi && !0 !== e.multi) throw new H("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph."); if ("boolean" == typeof e.allowSelfLoops && e.allowSelfLoops !== this.allowSelfLoops && !0 !== e.allowSelfLoops) throw new H("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph."); for (var t, r, n = this.emptyCopy(e), i = this._edges.values(); !0 !== (t = i.next()).done;)Pe(n, "copy", !1, (r = t.value).undirected, r.key, r.source.key, r.target.key, c({}, r.attributes)); return n }, i.toJSON = function () { return this.export() }, i.toString = function () { return "[object Graph]" }, i.inspect = function () { var t = this, r = {}; this._nodes.forEach((function (e, t) { r[t] = e.attributes })); var n = {}, i = {}; this._edges.forEach((function (e, r) { var o, a = e.undirected ? "--" : "->", s = "", c = e.source.key, u = e.target.key; e.undirected && c > u && (o = c, c = u, u = o); var h = "(".concat(c, ")").concat(a, "(").concat(u, ")"); r.startsWith("geid_") ? t.multi && (void 0 === i[h] ? i[h] = 0 : i[h]++, s += "".concat(i[h], ". ")) : s += "[".concat(r, "]: "), n[s += h] = e.attributes })); var o = {}; for (var a in this) this.hasOwnProperty(a) && !Fe.has(a) && "function" != typeof this[a] && "symbol" !== e(a) && (o[a] = this[a]); return o.attributes = this._attributes, o.nodes = r, o.edges = n, p(o, "constructor", this.constructor), o }, n }(m.exports.EventEmitter); "undefined" != typeof Symbol && (De.prototype[Symbol.for("nodejs.util.inspect.custom")] = De.prototype.inspect), [{ name: function (e) { return "".concat(e, "Edge") }, generateKey: !0 }, { name: function (e) { return "".concat(e, "DirectedEdge") }, generateKey: !0, type: "directed" }, { name: function (e) { return "".concat(e, "UndirectedEdge") }, generateKey: !0, type: "undirected" }, { name: function (e) { return "".concat(e, "EdgeWithKey") } }, { name: function (e) { return "".concat(e, "DirectedEdgeWithKey") }, type: "directed" }, { name: function (e) { return "".concat(e, "UndirectedEdgeWithKey") }, type: "undirected" }].forEach((function (e) { ["add", "merge", "update"].forEach((function (t) { var r = e.name(t), n = "add" === t ? Pe : Me; e.generateKey ? De.prototype[r] = function (i, o, a) { return n(this, r, !0, "undirected" === (e.type || this.type), null, i, o, a, "update" === t) } : De.prototype[r] = function (i, o, a, s) { return n(this, r, !1, "undirected" === (e.type || this.type), i, o, a, s, "update" === t) } })) })), function (e) { $.forEach((function (t) { var r = t.name, n = t.attacher; n(e, r("Node"), 0), n(e, r("Source"), 1), n(e, r("Target"), 2), n(e, r("Opposite"), 3) })) }(De), function (e) { J.forEach((function (t) { var r = t.name, n = t.attacher; n(e, r("Edge"), "mixed"), n(e, r("DirectedEdge"), "directed"), n(e, r("UndirectedEdge"), "undirected") })) }(De), function (e) { re.forEach((function (t) { !function (e, t) { var r = t.name, n = t.type, i = t.direction; e.prototype[r] = function (e, t) { if ("mixed" !== n && "mixed" !== this.type && n !== this.type) return []; if (!arguments.length) return ue(this, n); if (1 === arguments.length) { e = "" + e; var o = this._nodes.get(e); if (void 0 === o) throw new q("Graph.".concat(r, ': could not find the "').concat(e, '" node in the graph.')); return pe(this.multi, "mixed" === n ? this.type : n, i, o) } if (2 === arguments.length) { e = "" + e, t = "" + t; var a = this._nodes.get(e); if (!a) throw new q("Graph.".concat(r, ':  could not find the "').concat(e, '" source node in the graph.')); if (!this._nodes.has(t)) throw new q("Graph.".concat(r, ':  could not find the "').concat(t, '" target node in the graph.')); return ye(n, this.multi, i, a, t) } throw new W("Graph.".concat(r, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ").")) } }(e, t), function (e, t) { var r = t.name, n = t.type, i = t.direction, o = "forEach" + r[0].toUpperCase() + r.slice(1, -1); e.prototype[o] = function (e, t, r) { if ("mixed" === n || "mixed" === this.type || n === this.type) { if (1 === arguments.length) return he(!1, this, n, r = e); if (2 === arguments.length) { e = "" + e, r = t; var a = this._nodes.get(e); if (void 0 === a) throw new q("Graph.".concat(o, ': could not find the "').concat(e, '" node in the graph.')); return le(!1, this.multi, "mixed" === n ? this.type : n, i, a, r) } if (3 === arguments.length) { e = "" + e, t = "" + t; var s = this._nodes.get(e); if (!s) throw new q("Graph.".concat(o, ':  could not find the "').concat(e, '" source node in the graph.')); if (!this._nodes.has(t)) throw new q("Graph.".concat(o, ':  could not find the "').concat(t, '" target node in the graph.')); return ge(!1, n, this.multi, i, s, t, r) } throw new W("Graph.".concat(o, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ").")) } }; var a = "map" + r[0].toUpperCase() + r.slice(1); e.prototype[a] = function () { var e, t = Array.prototype.slice.call(arguments), r = t.pop(); if (0 === t.length) { var i = 0; "directed" !== n && (i += this.undirectedSize), "undirected" !== n && (i += this.directedSize), e = new Array(i); var a = 0; t.push((function (t, n, i, o, s, c, u) { e[a++] = r(t, n, i, o, s, c, u) })) } else e = [], t.push((function (t, n, i, o, a, s, c) { e.push(r(t, n, i, o, a, s, c)) })); return this[o].apply(this, t), e }; var s = "filter" + r[0].toUpperCase() + r.slice(1); e.prototype[s] = function () { var e = Array.prototype.slice.call(arguments), t = e.pop(), r = []; return e.push((function (e, n, i, o, a, s, c) { t(e, n, i, o, a, s, c) && r.push(e) })), this[o].apply(this, e), r }; var c = "reduce" + r[0].toUpperCase() + r.slice(1); e.prototype[c] = function () { var e, t, r = Array.prototype.slice.call(arguments); if (r.length < 2 || r.length > 4) throw new W("Graph.".concat(c, ": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(r.length, ").")); if ("function" == typeof r[r.length - 1] && "function" != typeof r[r.length - 2]) throw new W("Graph.".concat(c, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.")); 2 === r.length ? (e = r[0], t = r[1], r = []) : 3 === r.length ? (e = r[1], t = r[2], r = [r[0]]) : 4 === r.length && (e = r[2], t = r[3], r = [r[0], r[1]]); var n = t; return r.push((function (t, r, i, o, a, s, c) { n = e(n, t, r, i, o, a, s, c) })), this[o].apply(this, r), n } }(e, t), function (e, t) { var r = t.name, n = t.type, i = t.direction, o = "find" + r[0].toUpperCase() + r.slice(1, -1); e.prototype[o] = function (e, t, r) { if ("mixed" !== n && "mixed" !== this.type && n !== this.type) return !1; if (1 === arguments.length) return he(!0, this, n, r = e); if (2 === arguments.length) { e = "" + e, r = t; var a = this._nodes.get(e); if (void 0 === a) throw new q("Graph.".concat(o, ': could not find the "').concat(e, '" node in the graph.')); return le(!0, this.multi, "mixed" === n ? this.type : n, i, a, r) } if (3 === arguments.length) { e = "" + e, t = "" + t; var s = this._nodes.get(e); if (!s) throw new q("Graph.".concat(o, ':  could not find the "').concat(e, '" source node in the graph.')); if (!this._nodes.has(t)) throw new q("Graph.".concat(o, ':  could not find the "').concat(t, '" target node in the graph.')); return ge(!0, n, this.multi, i, s, t, r) } throw new W("Graph.".concat(o, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ").")) }; var a = "some" + r[0].toUpperCase() + r.slice(1, -1); e.prototype[a] = function () { var e = Array.prototype.slice.call(arguments), t = e.pop(); return e.push((function (e, r, n, i, o, a, s) { return t(e, r, n, i, o, a, s) })), !!this[o].apply(this, e) }; var s = "every" + r[0].toUpperCase() + r.slice(1, -1); e.prototype[s] = function () { var e = Array.prototype.slice.call(arguments), t = e.pop(); return e.push((function (e, r, n, i, o, a, s) { return !t(e, r, n, i, o, a, s) })), !this[o].apply(this, e) } }(e, t), function (e, t) { var r = t.name, n = t.type, i = t.direction, o = r.slice(0, -1) + "Entries"; e.prototype[o] = function (e, t) { if ("mixed" !== n && "mixed" !== this.type && n !== this.type) return M.empty(); if (!arguments.length) return de(this, n); if (1 === arguments.length) { e = "" + e; var r = this._nodes.get(e); if (!r) throw new q("Graph.".concat(o, ': could not find the "').concat(e, '" node in the graph.')); return fe(n, i, r) } if (2 === arguments.length) { e = "" + e, t = "" + t; var a = this._nodes.get(e); if (!a) throw new q("Graph.".concat(o, ':  could not find the "').concat(e, '" source node in the graph.')); if (!this._nodes.has(t)) throw new q("Graph.".concat(o, ':  could not find the "').concat(t, '" target node in the graph.')); return me(n, i, a, t) } throw new W("Graph.".concat(o, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ").")) } }(e, t) })) }(De), function (e) { ve.forEach((function (t) { (function (e, t) { var r = t.name, n = t.type, i = t.direction; e.prototype[r] = function (e) { if ("mixed" !== n && "mixed" !== this.type && n !== this.type) return []; e = "" + e; var t = this._nodes.get(e); if (void 0 === t) throw new q("Graph.".concat(r, ': could not find the "').concat(e, '" node in the graph.')); return function (e, t, r) { if ("mixed" !== e) { if ("undirected" === e) return Object.keys(r.undirected); if ("string" == typeof t) return Object.keys(r[t]) } var n = []; return _e(!1, e, t, r, (function (e) { n.push(e) })), n }("mixed" === n ? this.type : n, i, t) } })(e, t), function (e, t) { var r = t.name, n = t.type, i = t.direction, o = "forEach" + r[0].toUpperCase() + r.slice(1, -1); e.prototype[o] = function (e, t) { if ("mixed" === n || "mixed" === this.type || n === this.type) { e = "" + e; var r = this._nodes.get(e); if (void 0 === r) throw new q("Graph.".concat(o, ': could not find the "').concat(e, '" node in the graph.')); _e(!1, "mixed" === n ? this.type : n, i, r, t) } }; var a = "map" + r[0].toUpperCase() + r.slice(1); e.prototype[a] = function (e, t) { var r = []; return this[o](e, (function (e, n) { r.push(t(e, n)) })), r }; var s = "filter" + r[0].toUpperCase() + r.slice(1); e.prototype[s] = function (e, t) { var r = []; return this[o](e, (function (e, n) { t(e, n) && r.push(e) })), r }; var c = "reduce" + r[0].toUpperCase() + r.slice(1); e.prototype[c] = function (e, t, r) { if (arguments.length < 3) throw new W("Graph.".concat(c, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.")); var n = r; return this[o](e, (function (e, r) { n = t(n, e, r) })), n } }(e, t), function (e, t) { var r = t.name, n = t.type, i = t.direction, o = r[0].toUpperCase() + r.slice(1, -1), a = "find" + o; e.prototype[a] = function (e, t) { if ("mixed" === n || "mixed" === this.type || n === this.type) { e = "" + e; var r = this._nodes.get(e); if (void 0 === r) throw new q("Graph.".concat(a, ': could not find the "').concat(e, '" node in the graph.')); return _e(!0, "mixed" === n ? this.type : n, i, r, t) } }; var s = "some" + o; e.prototype[s] = function (e, t) { return !!this[a](e, t) }; var c = "every" + o; e.prototype[c] = function (e, t) { return !this[a](e, (function (e, r) { return !t(e, r) })) } }(e, t), function (e, t) { var r = t.name, n = t.type, i = t.direction, o = r.slice(0, -1) + "Entries"; e.prototype[o] = function (e) { if ("mixed" !== n && "mixed" !== this.type && n !== this.type) return M.empty(); e = "" + e; var t = this._nodes.get(e); if (void 0 === t) throw new q("Graph.".concat(o, ': could not find the "').concat(e, '" node in the graph.')); return function (e, t, r) { if ("mixed" !== e) { if ("undirected" === e) return xe(null, r, r.undirected); if ("string" == typeof t) return xe(null, r, r[t]) } var n = M.empty(), i = new be; return "undirected" !== e && ("out" !== t && (n = te(n, xe(i, r, r.in))), "in" !== t && (n = te(n, xe(i, r, r.out)))), "directed" !== e && (n = te(n, xe(i, r, r.undirected))), n }("mixed" === n ? this.type : n, i, t) } }(e, t) })) }(De); var Ge = function (e) { function r(t) { var r = c({ type: "directed" }, t); if ("multi" in r && !1 !== r.multi) throw new W("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!"); if ("directed" !== r.type) throw new W('DirectedGraph.from: inconsistent "' + r.type + '" type in given options!'); return e.call(this, r) || this } return t(r, e), r }(De), Ne = function (e) { function r(t) { var r = c({ type: "undirected" }, t); if ("multi" in r && !1 !== r.multi) throw new W("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!"); if ("undirected" !== r.type) throw new W('UndirectedGraph.from: inconsistent "' + r.type + '" type in given options!'); return e.call(this, r) || this } return t(r, e), r }(De), je = function (e) { function r(t) { var r = c({ multi: !0 }, t); if ("multi" in r && !0 !== r.multi) throw new W("MultiGraph.from: inconsistent indication that the graph should be simple in given options!"); return e.call(this, r) || this } return t(r, e), r }(De), Be = function (e) { function r(t) { var r = c({ type: "directed", multi: !0 }, t); if ("multi" in r && !0 !== r.multi) throw new W("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!"); if ("directed" !== r.type) throw new W('MultiDirectedGraph.from: inconsistent "' + r.type + '" type in given options!'); return e.call(this, r) || this } return t(r, e), r }(De), ze = function (e) { function r(t) { var r = c({ type: "undirected", multi: !0 }, t); if ("multi" in r && !0 !== r.multi) throw new W("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!"); if ("undirected" !== r.type) throw new W('MultiUndirectedGraph.from: inconsistent "' + r.type + '" type in given options!'); return e.call(this, r) || this } return t(r, e), r }(De); function Ue(e) { e.from = function (t, r) { var n = c({}, t.options, r), i = new e(n); return i.import(t), i } } return Ue(De), Ue(Ge), Ue(Ne), Ue(je), Ue(Be), Ue(ze), De.Graph = De, De.DirectedGraph = Ge, De.UndirectedGraph = Ne, De.MultiGraph = je, De.MultiDirectedGraph = Be, De.MultiUndirectedGraph = ze, De.InvalidArgumentsGraphError = W, De.NotFoundGraphError = q, De.UsageGraphError = H, De }() }, 7554: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }), o = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); var a = r(5227), s = o(r(8941)), c = r(4524), u = r(3291), h = 1.5, d = function (e) { function t() { var t = e.call(this) || this; return t.x = .5, t.y = .5, t.angle = 0, t.ratio = 1, t.minRatio = null, t.maxRatio = null, t.nextFrame = null, t.previousState = null, t.enabled = !0, t.previousState = t.getState(), t } return i(t, e), t.from = function (e) { return (new t).setState(e) }, t.prototype.enable = function () { return this.enabled = !0, this }, t.prototype.disable = function () { return this.enabled = !1, this }, t.prototype.getState = function () { return { x: this.x, y: this.y, angle: this.angle, ratio: this.ratio } }, t.prototype.hasState = function (e) { return this.x === e.x && this.y === e.y && this.ratio === e.ratio && this.angle === e.angle }, t.prototype.getPreviousState = function () { var e = this.previousState; return e ? { x: e.x, y: e.y, angle: e.angle, ratio: e.ratio } : null }, t.prototype.getBoundedRatio = function (e) { var t = e; return "number" == typeof this.minRatio && (t = Math.max(t, this.minRatio)), "number" == typeof this.maxRatio && (t = Math.min(t, this.maxRatio)), t }, t.prototype.validateState = function (e) { var t = {}; return "number" == typeof e.x && (t.x = e.x), "number" == typeof e.y && (t.y = e.y), "number" == typeof e.angle && (t.angle = e.angle), "number" == typeof e.ratio && (t.ratio = this.getBoundedRatio(e.ratio)), t }, t.prototype.isAnimated = function () { return !!this.nextFrame }, t.prototype.setState = function (e) { if (!this.enabled) return this; this.previousState = this.getState(); var t = this.validateState(e); return "number" == typeof t.x && (this.x = t.x), "number" == typeof t.y && (this.y = t.y), "number" == typeof t.angle && (this.angle = t.angle), "number" == typeof t.ratio && (this.ratio = t.ratio), this.hasState(this.previousState) || this.emit("updated", this.getState()), this }, t.prototype.animate = function (e, t, r) { var n = this; if (this.enabled) { var i = Object.assign({}, a.ANIMATE_DEFAULTS, t), o = this.validateState(e), u = "function" == typeof i.easing ? i.easing : s.default[i.easing], h = Date.now(), d = this.getState(), l = function () { var e = (Date.now() - h) / i.duration; if (e >= 1) return n.nextFrame = null, n.setState(o), void (n.animationCallback && (n.animationCallback.call(null), n.animationCallback = void 0)); var t = u(e), r = {}; "number" == typeof o.x && (r.x = d.x + (o.x - d.x) * t), "number" == typeof o.y && (r.y = d.y + (o.y - d.y) * t), "number" == typeof o.angle && (r.angle = d.angle + (o.angle - d.angle) * t), "number" == typeof o.ratio && (r.ratio = d.ratio + (o.ratio - d.ratio) * t), n.setState(r), n.nextFrame = (0, c.requestFrame)(l) }; this.nextFrame ? ((0, c.cancelFrame)(this.nextFrame), this.animationCallback && this.animationCallback.call(null), this.nextFrame = (0, c.requestFrame)(l)) : l(), this.animationCallback = r } }, t.prototype.animatedZoom = function (e) { if (e) { if ("number" == typeof e) return this.animate({ ratio: this.ratio / e }); this.animate({ ratio: this.ratio / (e.factor || h) }, e) } else this.animate({ ratio: this.ratio / h }) }, t.prototype.animatedUnzoom = function (e) { if (e) { if ("number" == typeof e) return this.animate({ ratio: this.ratio * e }); this.animate({ ratio: this.ratio * (e.factor || h) }, e) } else this.animate({ ratio: this.ratio * h }) }, t.prototype.animatedReset = function (e) { this.animate({ x: .5, y: .5, ratio: 1, angle: 0 }, e) }, t.prototype.copy = function () { return t.from(this.getState()) }, t }(u.TypedEventEmitter); t.default = d }, 3760: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }), o = this && this.__assign || function () { return o = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++)for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }, o.apply(this, arguments) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.getWheelDelta = t.getTouchCoords = t.getTouchesArray = t.getWheelCoords = t.getMouseCoords = t.getPosition = void 0; var a = r(3291); function s(e, t) { var r = t.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top } } function c(e, t) { var r = o(o({}, s(e, t)), { sigmaDefaultPrevented: !1, preventSigmaDefault: function () { r.sigmaDefaultPrevented = !0 }, original: e }); return r } function u(e) { for (var t = [], r = 0, n = Math.min(e.length, 2); r < n; r++)t.push(e[r]); return t } function h(e) { if (void 0 !== e.deltaY) return -3 * e.deltaY / 360; if (void 0 !== e.detail) return e.detail / -9; throw new Error("Captor: could not extract delta from event.") } t.getPosition = s, t.getMouseCoords = c, t.getWheelCoords = function (e, t) { return o(o({}, c(e, t)), { delta: h(e) }) }, t.getTouchesArray = u, t.getTouchCoords = function (e, t) { return { touches: u(e.touches).map((function (e) { return s(e, t) })), original: e } }, t.getWheelDelta = h; var d = function (e) { function t(t, r) { var n = e.call(this) || this; return n.container = t, n.renderer = r, n } return i(t, e), t }(a.TypedEventEmitter); t.default = d }, 9886: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }), o = this && this.__createBinding || (Object.create ? function (e, t, r, n) { void 0 === n && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function () { return t[r] } }) } : function (e, t, r, n) { void 0 === n && (n = r), e[n] = t[r] }), a = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), s = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && o(t, e, r); return a(t, e), t }; Object.defineProperty(t, "__esModule", { value: !0 }); var c = s(r(3760)), u = function (e) { function t(t, r) { var n = e.call(this, t, r) || this; return n.enabled = !0, n.draggedEvents = 0, n.downStartTime = null, n.lastMouseX = null, n.lastMouseY = null, n.isMouseDown = !1, n.isMoving = !1, n.movingTimeout = null, n.startCameraState = null, n.clicks = 0, n.doubleClickTimeout = null, n.currentWheelDirection = 0, n.handleClick = n.handleClick.bind(n), n.handleRightClick = n.handleRightClick.bind(n), n.handleDown = n.handleDown.bind(n), n.handleUp = n.handleUp.bind(n), n.handleMove = n.handleMove.bind(n), n.handleWheel = n.handleWheel.bind(n), n.handleOut = n.handleOut.bind(n), t.addEventListener("click", n.handleClick, !1), t.addEventListener("contextmenu", n.handleRightClick, !1), t.addEventListener("mousedown", n.handleDown, !1), t.addEventListener("wheel", n.handleWheel, !1), t.addEventListener("mouseout", n.handleOut, !1), document.addEventListener("mousemove", n.handleMove, !1), document.addEventListener("mouseup", n.handleUp, !1), n } return i(t, e), t.prototype.kill = function () { var e = this.container; e.removeEventListener("click", this.handleClick), e.removeEventListener("contextmenu", this.handleRightClick), e.removeEventListener("mousedown", this.handleDown), e.removeEventListener("wheel", this.handleWheel), e.removeEventListener("mouseout", this.handleOut), document.removeEventListener("mousemove", this.handleMove), document.removeEventListener("mouseup", this.handleUp) }, t.prototype.handleClick = function (e) { var t = this; if (this.enabled) { if (this.clicks++, 2 === this.clicks) return this.clicks = 0, "number" == typeof this.doubleClickTimeout && (clearTimeout(this.doubleClickTimeout), this.doubleClickTimeout = null), this.handleDoubleClick(e); setTimeout((function () { t.clicks = 0, t.doubleClickTimeout = null }), 300), this.draggedEvents < 3 && this.emit("click", (0, c.getMouseCoords)(e, this.container)) } }, t.prototype.handleRightClick = function (e) { this.enabled && this.emit("rightClick", (0, c.getMouseCoords)(e, this.container)) }, t.prototype.handleDoubleClick = function (e) { if (this.enabled) { e.preventDefault(), e.stopPropagation(); var t = (0, c.getMouseCoords)(e, this.container); if (this.emit("doubleClick", t), !t.sigmaDefaultPrevented) { var r = this.renderer.getCamera(), n = r.getBoundedRatio(r.getState().ratio / 2.2); r.animate(this.renderer.getViewportZoomedState((0, c.getPosition)(e, this.container), n), { easing: "quadraticInOut", duration: 200 }) } } }, t.prototype.handleDown = function (e) { if (this.enabled) { this.startCameraState = this.renderer.getCamera().getState(); var t = (0, c.getPosition)(e, this.container), r = t.x, n = t.y; this.lastMouseX = r, this.lastMouseY = n, this.draggedEvents = 0, this.downStartTime = Date.now(), this.isMouseDown = !0, this.emit("mousedown", (0, c.getMouseCoords)(e, this.container)) } }, t.prototype.handleUp = function (e) { var t = this; if (this.enabled && this.isMouseDown) { var r = this.renderer.getCamera(); this.isMouseDown = !1, "number" == typeof this.movingTimeout && (clearTimeout(this.movingTimeout), this.movingTimeout = null); var n = (0, c.getPosition)(e, this.container), i = n.x, o = n.y, a = r.getState(), s = r.getPreviousState() || { x: 0, y: 0 }; this.isMoving ? r.animate({ x: a.x + 3 * (a.x - s.x), y: a.y + 3 * (a.y - s.y) }, { duration: 200, easing: "quadraticOut" }) : this.lastMouseX === i && this.lastMouseY === o || r.setState({ x: a.x, y: a.y }), this.isMoving = !1, setTimeout((function () { t.draggedEvents = 0, t.renderer.refresh() }), 0), this.emit("mouseup", (0, c.getMouseCoords)(e, this.container)) } }, t.prototype.handleMove = function (e) { var t = this; if (this.enabled) { var r = (0, c.getMouseCoords)(e, this.container); if (this.emit("mousemovebody", r), e.target === this.container && this.emit("mousemove", r), !r.sigmaDefaultPrevented && this.isMouseDown) { this.isMoving = !0, this.draggedEvents++, "number" == typeof this.movingTimeout && clearTimeout(this.movingTimeout), this.movingTimeout = window.setTimeout((function () { t.movingTimeout = null, t.isMoving = !1 }), 100); var n = this.renderer.getCamera(), i = (0, c.getPosition)(e, this.container), o = i.x, a = i.y, s = this.renderer.viewportToFramedGraph({ x: this.lastMouseX, y: this.lastMouseY }), u = this.renderer.viewportToFramedGraph({ x: o, y: a }), h = s.x - u.x, d = s.y - u.y, l = n.getState(), p = l.x + h, f = l.y + d; n.setState({ x: p, y: f }), this.lastMouseX = o, this.lastMouseY = a, e.preventDefault(), e.stopPropagation() } } }, t.prototype.handleWheel = function (e) { var t = this; if (this.enabled) { e.preventDefault(), e.stopPropagation(); var r = (0, c.getWheelDelta)(e); if (r) { var n = (0, c.getWheelCoords)(e, this.container); if (this.emit("wheel", n), !n.sigmaDefaultPrevented) { var i = r > 0 ? 1 / 1.7 : 1.7, o = this.renderer.getCamera(), a = o.getBoundedRatio(o.getState().ratio * i), s = r > 0 ? 1 : -1, u = Date.now(); this.currentWheelDirection === s && this.lastWheelTriggerTime && u - this.lastWheelTriggerTime < 50 || (o.animate(this.renderer.getViewportZoomedState((0, c.getPosition)(e, this.container), a), { easing: "quadraticOut", duration: 250 }, (function () { t.currentWheelDirection = 0 })), this.currentWheelDirection = s, this.lastWheelTriggerTime = u) } } } }, t.prototype.handleOut = function () { }, t }(c.default); t.default = u }, 9311: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }), o = this && this.__createBinding || (Object.create ? function (e, t, r, n) { void 0 === n && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function () { return t[r] } }) } : function (e, t, r, n) { void 0 === n && (n = r), e[n] = t[r] }), a = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), s = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && o(t, e, r); return a(t, e), t }, c = this && this.__read || function (e, t) { var r = "function" == typeof Symbol && e[Symbol.iterator]; if (!r) return e; var n, i, o = r.call(e), a = []; try { for (; (void 0 === t || t-- > 0) && !(n = o.next()).done;)a.push(n.value) } catch (e) { i = { error: e } } finally { try { n && !n.done && (r = o.return) && r.call(o) } finally { if (i) throw i.error } } return a }; Object.defineProperty(t, "__esModule", { value: !0 }); var u = s(r(3760)), h = function (e) { function t(t, r) { var n = e.call(this, t, r) || this; return n.enabled = !0, n.isMoving = !1, n.touchMode = 0, n.handleStart = n.handleStart.bind(n), n.handleLeave = n.handleLeave.bind(n), n.handleMove = n.handleMove.bind(n), t.addEventListener("touchstart", n.handleStart, !1), t.addEventListener("touchend", n.handleLeave, !1), t.addEventListener("touchcancel", n.handleLeave, !1), t.addEventListener("touchmove", n.handleMove, !1), n } return i(t, e), t.prototype.kill = function () { var e = this.container; e.removeEventListener("touchstart", this.handleStart), e.removeEventListener("touchend", this.handleLeave), e.removeEventListener("touchcancel", this.handleLeave), e.removeEventListener("touchmove", this.handleMove) }, t.prototype.getDimensions = function () { return { width: this.container.offsetWidth, height: this.container.offsetHeight } }, t.prototype.dispatchRelatedMouseEvent = function (e, t, r, n) { var i = r || (0, u.getPosition)(t.touches[0], this.container), o = new MouseEvent(e, { clientX: i.x, clientY: i.y, altKey: t.altKey, ctrlKey: t.ctrlKey }); o.isFakeSigmaMouseEvent = !0, (n || this.container).dispatchEvent(o) }, t.prototype.handleStart = function (e) { var t = this; if (this.enabled) { e.preventDefault(), 1 === e.touches.length && this.dispatchRelatedMouseEvent("mousedown", e); var r = (0, u.getTouchesArray)(e.touches); if (this.isMoving = !0, this.touchMode = r.length, this.startCameraState = this.renderer.getCamera().getState(), this.startTouchesPositions = r.map((function (e) { return (0, u.getPosition)(e, t.container) })), this.lastTouchesPositions = this.startTouchesPositions, 2 === this.touchMode) { var n = c(this.startTouchesPositions, 2), i = n[0], o = i.x, a = i.y, s = n[1], h = s.x, d = s.y; this.startTouchesAngle = Math.atan2(d - a, h - o), this.startTouchesDistance = Math.sqrt(Math.pow(h - o, 2) + Math.pow(d - a, 2)) } this.emit("touchdown", (0, u.getTouchCoords)(e, this.container)) } }, t.prototype.handleLeave = function (e) { if (this.enabled) { switch (e.preventDefault(), 0 === e.touches.length && this.lastTouchesPositions && this.lastTouchesPositions.length && (this.dispatchRelatedMouseEvent("mouseup", e, this.lastTouchesPositions[0], document), this.dispatchRelatedMouseEvent("click", e, this.lastTouchesPositions[0])), this.movingTimeout && (this.isMoving = !1, clearTimeout(this.movingTimeout)), this.touchMode) { case 2: if (1 === e.touches.length) { this.handleStart(e), e.preventDefault(); break } case 1: if (this.isMoving) { var t = this.renderer.getCamera(), r = t.getState(), n = t.getPreviousState() || { x: 0, y: 0 }; t.animate({ x: r.x + 3 * (r.x - n.x), y: r.y + 3 * (r.y - n.y) }, { duration: 200, easing: "quadraticOut" }) } this.isMoving = !1, this.touchMode = 0 }this.emit("touchup", (0, u.getTouchCoords)(e, this.container)) } }, t.prototype.handleMove = function (e) { var t, r = this; if (this.enabled) { e.preventDefault(), 1 === e.touches.length && this.dispatchRelatedMouseEvent("mousemove", e); var n = this.renderer.getCamera(), i = this.startCameraState, o = (0, u.getTouchesArray)(e.touches).map((function (e) { return (0, u.getPosition)(e, r.container) })); switch (this.lastTouchesPositions = o, this.isMoving = !0, this.movingTimeout && clearTimeout(this.movingTimeout), this.movingTimeout = window.setTimeout((function () { r.isMoving = !1 }), 200), this.touchMode) { case 1: var a = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]), s = a.x, h = a.y, d = this.renderer.viewportToFramedGraph(o[0]), l = d.x, p = d.y; n.setState({ x: i.x + s - l, y: i.y + h - p }); break; case 2: var f = {}, g = o[0], y = g.x, m = g.y, v = o[1], b = v.x, w = v.y, _ = Math.atan2(w - m, b - y) - this.startTouchesAngle, x = Math.hypot(w - m, b - y) / this.startTouchesDistance, E = n.getBoundedRatio(i.ratio / x); f.ratio = E, f.angle = i.angle + _; var C = this.getDimensions(), k = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], { cameraState: i }), L = Math.min(C.width, C.height), A = L / C.width, S = E / L; p = m - L / 2 / (L / C.height), l = (t = c([(l = y - L / 2 / A) * Math.cos(-f.angle) - p * Math.sin(-f.angle), p * Math.cos(-f.angle) + l * Math.sin(-f.angle)], 2))[0], p = t[1], f.x = k.x - l * S, f.y = k.y + p * S, n.setState(f) }this.emit("touchmove", (0, u.getTouchCoords)(e, this.container)) } }, t }(u.default); t.default = h }, 8098: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.edgeLabelsToDisplayFromNodes = t.LabelGrid = void 0; var r = function () { function e(e, t) { this.key = e, this.size = t } return e.compare = function (e, t) { return e.size > t.size ? -1 : e.size < t.size || e.key > t.key ? 1 : -1 }, e }(), n = function () { function e() { this.width = 0, this.height = 0, this.cellSize = 0, this.columns = 0, this.rows = 0, this.cells = {} } return e.prototype.resizeAndClear = function (e, t) { this.width = e.width, this.height = e.height, this.cellSize = t, this.columns = Math.ceil(e.width / t), this.rows = Math.ceil(e.height / t), this.cells = {} }, e.prototype.getIndex = function (e) { var t = Math.floor(e.x / this.cellSize); return Math.floor(e.y / this.cellSize) * this.columns + t }, e.prototype.add = function (e, t, n) { var i = new r(e, t), o = this.getIndex(n), a = this.cells[o]; a || (a = [], this.cells[o] = a), a.push(i) }, e.prototype.organize = function () { for (var e in this.cells) this.cells[e].sort(r.compare) }, e.prototype.getLabelsToDisplay = function (e, t) { var r = this.cellSize * this.cellSize, n = r / e / e * t / r, i = Math.ceil(n), o = []; for (var a in this.cells) for (var s = this.cells[a], c = 0; c < Math.min(i, s.length); c++)o.push(s[c].key); return o }, e }(); t.LabelGrid = n, t.edgeLabelsToDisplayFromNodes = function (e) { var t = e.graph, r = e.hoveredNode, n = e.highlightedNodes, i = e.displayedNodeLabels, o = []; return t.forEachEdge((function (e, t, a, s) { (a === r || s === r || n.has(a) || n.has(s) || i.has(a) && i.has(s)) && o.push(e) })), o } }, 1461: function (e, t, r) { "use strict"; var n = this && this.__read || function (e, t) { var r = "function" == typeof Symbol && e[Symbol.iterator]; if (!r) return e; var n, i, o = r.call(e), a = []; try { for (; (void 0 === t || t-- > 0) && !(n = o.next()).done;)a.push(n.value) } catch (e) { i = { error: e } } finally { try { n && !n.done && (r = o.return) && r.call(o) } finally { if (i) throw i.error } } return a }, i = this && this.__spreadArray || function (e, t, r) { if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++)!n && i in t || (n || (n = Array.prototype.slice.call(t, 0, i)), n[i] = t[i]); return e.concat(n || Array.prototype.slice.call(t)) }, o = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.rectangleCollidesWithQuad = t.squareCollidesWithQuad = t.getCircumscribedAlignedRectangle = t.isRectangleAligned = void 0; var a = o(r(3796)), s = !1; function c(e) { return e.x1 === e.x2 || e.y1 === e.y2 } function u(e) { var t = Math.sqrt(Math.pow(e.x2 - e.x1, 2) + Math.pow(e.y2 - e.y1, 2)), r = (e.y1 - e.y2) * e.height / t, n = (e.x2 - e.x1) * e.height / t, i = { x: e.x1, y: e.y1 }, o = { x: e.x2, y: e.y2 }, a = { x: e.x1 + r, y: e.y1 + n }, s = { x: e.x2 + r, y: e.y2 + n }, c = Math.min(i.x, o.x, a.x, s.x), u = Math.max(i.x, o.x, a.x, s.x), h = Math.min(i.y, o.y, a.y, s.y); return { x1: c, y1: h, x2: u, y2: h, height: Math.max(i.y, o.y, a.y, s.y) - h } } function h(e, t, r, n, i, o, a) { return e < n + o && e + r > n && t < i + a && t + r > i } function d(e, t, r, n, i, o, a, s) { return e < i + a && e + r > i && t < o + s && t + n > o } function l(e, t, r, n, i, o) { var a = e < r + i / 2; return t < n + o / 2 ? a ? 1 : 2 : a ? 3 : 4 } t.isRectangleAligned = c, t.getCircumscribedAlignedRectangle = u, t.squareCollidesWithQuad = h, t.rectangleCollidesWithQuad = d; var p = function () { function e(e) { var t; void 0 === e && (e = {}), this.containers = ((t = {}).outside = [], t), this.cache = null, this.lastRectangle = null; var r = Math.pow(4, 5); this.data = new Float32Array((4 * r - 1) / 3 * 4), e.boundaries ? this.resize(e.boundaries) : this.resize({ x: 0, y: 0, width: 1, height: 1 }) } return e.prototype.add = function (e, t, r, n) { return function (e, t, r, n, i, o, a) { for (var c = i - a, u = o - a, d = 2 * a, l = 0, p = 0; ;) { if (l >= 5) return r[p] = r[p] || [], void r[p].push(n); var f = 4 * p + 4, g = 4 * p + 8, y = 4 * p + 12, m = 4 * p + 16, v = h(c, u, d, t[f + 0], t[f + 1], t[f + 2], t[f + 3]), b = h(c, u, d, t[g + 0], t[g + 1], t[g + 2], t[g + 3]), w = h(c, u, d, t[y + 0], t[y + 1], t[y + 2], t[y + 3]), _ = h(c, u, d, t[m + 0], t[m + 1], t[m + 2], t[m + 3]), x = [v, b, w, _].reduce((function (e, t) { return t ? e + 1 : e }), 0); if (0 === x && 0 === l) return r.outside.push(n), void (!s && r.outside.length >= 5 && (s = !0, console.warn("sigma/quadtree.insertNode: At least 5 nodes are outside the global quadtree zone. You might have a problem with the normalization function or the custom bounding box."))); if (0 === x) throw new Error("sigma/quadtree.insertNode: no collision (level: ".concat(l, ", key: ").concat(n, ", x: ").concat(i, ", y: ").concat(o, ", size: ").concat(a, ").")); if (3 === x) throw new Error("sigma/quadtree.insertNode: 3 impossible collisions (level: ".concat(l, ", key: ").concat(n, ", x: ").concat(i, ", y: ").concat(o, ", size: ").concat(a, ").")); if (x > 1) return r[p] = r[p] || [], void r[p].push(n); l++, v && (p = f), b && (p = g), w && (p = y), _ && (p = m) } }(0, this.data, this.containers, e, t, r, n), this }, e.prototype.resize = function (e) { this.clear(), this.data[0] = e.x, this.data[1] = e.y, this.data[2] = e.width, this.data[3] = e.height, function (e, t) { for (var r = [0, 0]; r.length;) { var n = r.pop(), i = r.pop(), o = 4 * i + 4, a = 4 * i + 8, s = 4 * i + 12, c = 4 * i + 16, u = t[i + 0], h = t[i + 1], d = t[i + 2] / 2, l = t[i + 3] / 2; t[o + 0] = u, t[o + 1] = h, t[o + 2] = d, t[o + 3] = l, t[a + 0] = u + d, t[a + 1] = h, t[a + 2] = d, t[a + 3] = l, t[s + 0] = u, t[s + 1] = h + l, t[s + 2] = d, t[s + 3] = l, t[c + 0] = u + d, t[c + 1] = h + l, t[c + 2] = d, t[c + 3] = l, n < 4 && (r.push(c, n + 1), r.push(s, n + 1), r.push(a, n + 1), r.push(o, n + 1)) } }(0, this.data) }, e.prototype.clear = function () { var e; return this.containers = ((e = {}).outside = [], e), this }, e.prototype.point = function (e, t) { var r = this.containers.outside, o = 0, a = 0; do { this.containers[o] && r.push.apply(r, i([], n(this.containers[o]), !1)), o = 4 * o + 4 * l(e, t, this.data[o + 0], this.data[o + 1], this.data[o + 2], this.data[o + 3]), a++ } while (a <= 5); return r }, e.prototype.rectangle = function (e, t, r, o, s) { var h, l = this.lastRectangle; return l && e === l.x1 && r === l.x2 && t === l.y1 && o === l.y2 && s === l.height || (this.lastRectangle = { x1: e, y1: t, x2: r, y2: o, height: s }, c(this.lastRectangle) || (this.lastRectangle = u(this.lastRectangle)), this.cache = function (e, t, r, n, i, o, s) { for (var c, u = [0, 0], h = []; u.length;) { var l = u.pop(), p = u.pop(); if ((c = r[p]) && (0, a.default)(h, c), !(l >= 5)) { var f = 4 * p + 4, g = 4 * p + 8, y = 4 * p + 12, m = 4 * p + 16, v = d(n, i, o, s, t[f + 0], t[f + 1], t[f + 2], t[f + 3]), b = d(n, i, o, s, t[g + 0], t[g + 1], t[g + 2], t[g + 3]), w = d(n, i, o, s, t[y + 0], t[y + 1], t[y + 2], t[y + 3]), _ = d(n, i, o, s, t[m + 0], t[m + 1], t[m + 2], t[m + 3]); v && u.push(f, l + 1), b && u.push(g, l + 1), w && u.push(y, l + 1), _ && u.push(m, l + 1) } } return h }(0, this.data, this.containers, e, t, Math.abs(e - r) || Math.abs(t - o), s), (h = this.cache).push.apply(h, i([], n(this.containers.outside), !1))), this.cache }, e }(); t.default = p }, 9026: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.Sigma = t.MouseCaptor = t.QuadTree = t.Camera = void 0; var i = n(r(248)); t.Sigma = i.default; var o = n(r(7554)); t.Camera = o.default; var a = n(r(1461)); t.QuadTree = a.default; var s = n(r(9886)); t.MouseCaptor = s.default, t.default = i.default }, 2294: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e, t, r, n, i) { var o = i.edgeLabelSize, a = i.edgeLabelFont, s = i.edgeLabelWeight, c = i.edgeLabelColor.attribute ? t[i.edgeLabelColor.attribute] || i.edgeLabelColor.color || "#000" : i.edgeLabelColor.color, u = t.label; if (u) { e.fillStyle = c, e.font = "".concat(s, " ").concat(o, "px ").concat(a); var h, d, l = r.size, p = n.size, f = r.x, g = r.y, y = n.x, m = n.y, v = y - f, b = m - g, w = Math.sqrt(v * v + b * b); if (!(w < l + p)) { h = ((f += v * l / w) + (y -= v * p / w)) / 2, d = ((g += b * l / w) + (m -= b * p / w)) / 2, v = y - f, b = m - g, w = Math.sqrt(v * v + b * b); var _, x = e.measureText(u).width; if (x > w) { for (u += "", x = e.measureText(u).width; x > w && u.length > 1;)u = u.slice(0, -2) + "", x = e.measureText(u).width; if (u.length < 4) return } _ = v > 0 ? b > 0 ? Math.acos(v / w) : Math.asin(b / w) : b > 0 ? Math.acos(v / w) + Math.PI : Math.asin(v / w) + Math.PI / 2, e.save(), e.translate(h, d), e.rotate(_), e.fillText(u, -x / 2, t.size / 2 + o), e.restore() } } } }, 4607: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(r(4577)); t.default = function (e, t, r) { var n = r.labelSize, o = r.labelFont, a = r.labelWeight; if (e.font = "".concat(a, " ").concat(n, "px ").concat(o), e.fillStyle = "#FFF", e.shadowOffsetX = 0, e.shadowOffsetY = 0, e.shadowBlur = 8, e.shadowColor = "#000", "string" == typeof t.label) { var s = e.measureText(t.label).width, c = Math.round(s + 5), u = Math.round(n + 4), h = Math.max(t.size, n / 2) + 2, d = Math.asin(u / 2 / h), l = Math.sqrt(Math.abs(Math.pow(h, 2) - Math.pow(u / 2, 2))); e.beginPath(), e.moveTo(t.x + l, t.y + u / 2), e.lineTo(t.x + h + c, t.y + u / 2), e.lineTo(t.x + h + c, t.y - u / 2), e.lineTo(t.x + l, t.y - u / 2), e.arc(t.x, t.y, h, d, -d), e.closePath(), e.fill() } else e.beginPath(), e.arc(t.x, t.y, t.size + 2, 0, 2 * Math.PI), e.closePath(), e.fill(); e.shadowOffsetX = 0, e.shadowOffsetY = 0, e.shadowBlur = 0, (0, i.default)(e, t, r) } }, 4577: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e, t, r) { if (t.label) { var n = r.labelSize, i = r.labelFont, o = r.labelWeight, a = r.labelColor.attribute ? t[r.labelColor.attribute] || r.labelColor.color || "#000" : r.labelColor.color; e.fillStyle = a, e.font = "".concat(o, " ").concat(n, "px ").concat(i), e.fillText(t.label, t.x + t.size + 3, t.y + n / 3) } } }, 4917: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }); Object.defineProperty(t, "__esModule", { value: !0 }), t.createEdgeCompoundProgram = t.AbstractEdgeProgram = void 0; var o = function (e) { function t(t, r, n, i, o) { return e.call(this, t, r, n, i, o) || this } return i(t, e), t }(r(7973).AbstractProgram); t.AbstractEdgeProgram = o, t.createEdgeCompoundProgram = function (e) { return function () { function t(t, r) { this.programs = e.map((function (e) { return new e(t, r) })) } return t.prototype.bufferData = function () { this.programs.forEach((function (e) { return e.bufferData() })) }, t.prototype.allocate = function (e) { this.programs.forEach((function (t) { return t.allocate(e) })) }, t.prototype.bind = function () { }, t.prototype.computeIndices = function () { this.programs.forEach((function (e) { return e.computeIndices() })) }, t.prototype.render = function (e) { this.programs.forEach((function (t) { t.bind(), t.bufferData(), t.render(e) })) }, t.prototype.process = function (e, t, r, n, i) { this.programs.forEach((function (o) { return o.process(e, t, r, n, i) })) }, t }() } }, 3533: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }); Object.defineProperty(t, "__esModule", { value: !0 }), t.createNodeCompoundProgram = t.AbstractNodeProgram = void 0; var o = function (e) { function t(t, r, n, i, o) { var a = e.call(this, t, r, n, i, o) || this; a.positionLocation = t.getAttribLocation(a.program, "a_position"), a.sizeLocation = t.getAttribLocation(a.program, "a_size"), a.colorLocation = t.getAttribLocation(a.program, "a_color"); var s = t.getUniformLocation(a.program, "u_matrix"); if (null === s) throw new Error("AbstractNodeProgram: error while getting matrixLocation"); a.matrixLocation = s; var c = t.getUniformLocation(a.program, "u_ratio"); if (null === c) throw new Error("AbstractNodeProgram: error while getting ratioLocation"); a.ratioLocation = c; var u = t.getUniformLocation(a.program, "u_scale"); if (null === u) throw new Error("AbstractNodeProgram: error while getting scaleLocation"); return a.scaleLocation = u, a } return i(t, e), t.prototype.bind = function () { var e = this.gl; e.enableVertexAttribArray(this.positionLocation), e.enableVertexAttribArray(this.sizeLocation), e.enableVertexAttribArray(this.colorLocation), e.vertexAttribPointer(this.positionLocation, 2, e.FLOAT, !1, this.attributes * Float32Array.BYTES_PER_ELEMENT, 0), e.vertexAttribPointer(this.sizeLocation, 1, e.FLOAT, !1, this.attributes * Float32Array.BYTES_PER_ELEMENT, 8), e.vertexAttribPointer(this.colorLocation, 4, e.UNSIGNED_BYTE, !0, this.attributes * Float32Array.BYTES_PER_ELEMENT, 12) }, t }(r(7973).AbstractProgram); t.AbstractNodeProgram = o, t.createNodeCompoundProgram = function (e) { return function () { function t(t, r) { this.programs = e.map((function (e) { return new e(t, r) })) } return t.prototype.bufferData = function () { this.programs.forEach((function (e) { return e.bufferData() })) }, t.prototype.allocate = function (e) { this.programs.forEach((function (t) { return t.allocate(e) })) }, t.prototype.bind = function () { }, t.prototype.render = function (e) { this.programs.forEach((function (t) { t.bind(), t.bufferData(), t.render(e) })) }, t.prototype.process = function (e, t, r) { this.programs.forEach((function (n) { return n.process(e, t, r) })) }, t }() } }, 7973: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.AbstractProgram = void 0; var n = r(1538), i = function () { function e(e, t, r, i, o) { this.array = new Float32Array, this.points = i, this.attributes = o, this.gl = e, this.vertexShaderSource = t, this.fragmentShaderSource = r; var a = e.createBuffer(); if (null === a) throw new Error("AbstractProgram: error while creating the buffer"); this.buffer = a, e.bindBuffer(e.ARRAY_BUFFER, this.buffer), this.vertexShader = (0, n.loadVertexShader)(e, this.vertexShaderSource), this.fragmentShader = (0, n.loadFragmentShader)(e, this.fragmentShaderSource), this.program = (0, n.loadProgram)(e, [this.vertexShader, this.fragmentShader]) } return e.prototype.bufferData = function () { var e = this.gl; e.bufferData(e.ARRAY_BUFFER, this.array, e.DYNAMIC_DRAW) }, e.prototype.allocate = function (e) { this.array = new Float32Array(this.points * this.attributes * e) }, e.prototype.hasNothingToRender = function () { return 0 === this.array.length }, e }(); t.AbstractProgram = i }, 4638: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); var i = r(4917), o = n(r(8747)), a = n(r(2874)), s = (0, i.createEdgeCompoundProgram)([a.default, o.default]); t.default = s }, 8747: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }), o = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); var a = r(4524), s = o(r(5191)), c = o(r(7083)), u = function (e) { function t(t) { var r = e.call(this, t, s.default, c.default, 3, 9) || this; r.positionLocation = t.getAttribLocation(r.program, "a_position"), r.colorLocation = t.getAttribLocation(r.program, "a_color"), r.normalLocation = t.getAttribLocation(r.program, "a_normal"), r.radiusLocation = t.getAttribLocation(r.program, "a_radius"), r.barycentricLocation = t.getAttribLocation(r.program, "a_barycentric"); var n = t.getUniformLocation(r.program, "u_matrix"); if (null === n) throw new Error("EdgeArrowHeadProgram: error while getting matrixLocation"); r.matrixLocation = n; var i = t.getUniformLocation(r.program, "u_sqrtZoomRatio"); if (null === i) throw new Error("EdgeArrowHeadProgram: error while getting sqrtZoomRatioLocation"); r.sqrtZoomRatioLocation = i; var o = t.getUniformLocation(r.program, "u_correctionRatio"); if (null === o) throw new Error("EdgeArrowHeadProgram: error while getting correctionRatioLocation"); return r.correctionRatioLocation = o, r.bind(), r } return i(t, e), t.prototype.bind = function () { var e = this.gl; e.enableVertexAttribArray(this.positionLocation), e.enableVertexAttribArray(this.normalLocation), e.enableVertexAttribArray(this.radiusLocation), e.enableVertexAttribArray(this.colorLocation), e.enableVertexAttribArray(this.barycentricLocation), e.vertexAttribPointer(this.positionLocation, 2, e.FLOAT, !1, 9 * Float32Array.BYTES_PER_ELEMENT, 0), e.vertexAttribPointer(this.normalLocation, 2, e.FLOAT, !1, 9 * Float32Array.BYTES_PER_ELEMENT, 8), e.vertexAttribPointer(this.radiusLocation, 1, e.FLOAT, !1, 9 * Float32Array.BYTES_PER_ELEMENT, 16), e.vertexAttribPointer(this.colorLocation, 4, e.UNSIGNED_BYTE, !0, 9 * Float32Array.BYTES_PER_ELEMENT, 20), e.vertexAttribPointer(this.barycentricLocation, 3, e.FLOAT, !1, 9 * Float32Array.BYTES_PER_ELEMENT, 24) }, t.prototype.computeIndices = function () { }, t.prototype.process = function (e, t, r, n, i) { if (n) for (var o = 27 * i, s = o + 27; o < s; o++)this.array[o] = 0; else { var c = r.size || 1, u = t.size || 1, h = e.x, d = e.y, l = t.x, p = t.y, f = (0, a.floatColor)(r.color), g = l - h, y = p - d, m = g * g + y * y, v = 0, b = 0; m && (v = -y * (m = 1 / Math.sqrt(m)) * c, b = g * m * c); var w = 27 * i, _ = this.array; _[w++] = l, _[w++] = p, _[w++] = -v, _[w++] = -b, _[w++] = u, _[w++] = f, _[w++] = 1, _[w++] = 0, _[w++] = 0, _[w++] = l, _[w++] = p, _[w++] = -v, _[w++] = -b, _[w++] = u, _[w++] = f, _[w++] = 0, _[w++] = 1, _[w++] = 0, _[w++] = l, _[w++] = p, _[w++] = -v, _[w++] = -b, _[w++] = u, _[w++] = f, _[w++] = 0, _[w++] = 0, _[w] = 1 } }, t.prototype.render = function (e) { if (!this.hasNothingToRender()) { var t = this.gl, r = this.program; t.useProgram(r), t.uniformMatrix3fv(this.matrixLocation, !1, e.matrix), t.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(e.ratio)), t.uniform1f(this.correctionRatioLocation, e.correctionRatio), t.drawArrays(t.TRIANGLES, 0, this.array.length / 9) } }, t }(r(4917).AbstractEdgeProgram); t.default = u }, 2874: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }), o = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); var a = r(4917), s = r(4524), c = o(r(8073)), u = o(r(4879)), h = function (e) { function t(t) { var r = e.call(this, t, c.default, u.default, 4, 6) || this, n = t.createBuffer(); if (null === n) throw new Error("EdgeClampedProgram: error while getting resolutionLocation"); r.indicesBuffer = n, r.positionLocation = t.getAttribLocation(r.program, "a_position"), r.colorLocation = t.getAttribLocation(r.program, "a_color"), r.normalLocation = t.getAttribLocation(r.program, "a_normal"), r.radiusLocation = t.getAttribLocation(r.program, "a_radius"); var i = t.getUniformLocation(r.program, "u_matrix"); if (null === i) throw new Error("EdgeClampedProgram: error while getting matrixLocation"); r.matrixLocation = i; var o = t.getUniformLocation(r.program, "u_sqrtZoomRatio"); if (null === o) throw new Error("EdgeClampedProgram: error while getting cameraRatioLocation"); r.sqrtZoomRatioLocation = o; var a = t.getUniformLocation(r.program, "u_correctionRatio"); if (null === a) throw new Error("EdgeClampedProgram: error while getting viewportRatioLocation"); return r.correctionRatioLocation = a, r.canUse32BitsIndices = (0, s.canUse32BitsIndices)(t), r.IndicesArray = r.canUse32BitsIndices ? Uint32Array : Uint16Array, r.indicesArray = new r.IndicesArray, r.indicesType = r.canUse32BitsIndices ? t.UNSIGNED_INT : t.UNSIGNED_SHORT, r.bind(), r } return i(t, e), t.prototype.bind = function () { var e = this.gl; e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indicesBuffer), e.enableVertexAttribArray(this.positionLocation), e.enableVertexAttribArray(this.normalLocation), e.enableVertexAttribArray(this.colorLocation), e.enableVertexAttribArray(this.radiusLocation), e.vertexAttribPointer(this.positionLocation, 2, e.FLOAT, !1, 6 * Float32Array.BYTES_PER_ELEMENT, 0), e.vertexAttribPointer(this.normalLocation, 2, e.FLOAT, !1, 6 * Float32Array.BYTES_PER_ELEMENT, 8), e.vertexAttribPointer(this.colorLocation, 4, e.UNSIGNED_BYTE, !0, 6 * Float32Array.BYTES_PER_ELEMENT, 16), e.vertexAttribPointer(this.radiusLocation, 1, e.FLOAT, !1, 6 * Float32Array.BYTES_PER_ELEMENT, 20) }, t.prototype.process = function (e, t, r, n, i) { if (n) for (var o = 24 * i, a = o + 24; o < a; o++)this.array[o] = 0; else { var c = r.size || 1, u = e.x, h = e.y, d = t.x, l = t.y, p = t.size || 1, f = (0, s.floatColor)(r.color), g = d - u, y = l - h, m = g * g + y * y, v = 0, b = 0; m && (v = -y * (m = 1 / Math.sqrt(m)) * c, b = g * m * c); var w = 24 * i, _ = this.array; _[w++] = u, _[w++] = h, _[w++] = v, _[w++] = b, _[w++] = f, _[w++] = 0, _[w++] = u, _[w++] = h, _[w++] = -v, _[w++] = -b, _[w++] = f, _[w++] = 0, _[w++] = d, _[w++] = l, _[w++] = v, _[w++] = b, _[w++] = f, _[w++] = p, _[w++] = d, _[w++] = l, _[w++] = -v, _[w++] = -b, _[w++] = f, _[w] = -p } }, t.prototype.computeIndices = function () { for (var e = this.array.length / 6, t = e + e / 2, r = new this.IndicesArray(t), n = 0, i = 0; n < e; n += 4)r[i++] = n, r[i++] = n + 1, r[i++] = n + 2, r[i++] = n + 2, r[i++] = n + 1, r[i++] = n + 3; this.indicesArray = r }, t.prototype.bufferData = function () { e.prototype.bufferData.call(this); var t = this.gl; t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indicesArray, t.STATIC_DRAW) }, t.prototype.render = function (e) { if (!this.hasNothingToRender()) { var t = this.gl, r = this.program; t.useProgram(r), t.uniformMatrix3fv(this.matrixLocation, !1, e.matrix), t.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(e.ratio)), t.uniform1f(this.correctionRatioLocation, e.correctionRatio), t.drawElements(t.TRIANGLES, this.indicesArray.length, this.indicesType, 0) } }, t }(a.AbstractEdgeProgram); t.default = h }, 5857: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }), o = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); var a = r(4524), s = o(r(372)), c = o(r(4879)), u = function (e) { function t(t) { var r = e.call(this, t, s.default, c.default, 4, 5) || this, n = t.createBuffer(); if (null === n) throw new Error("EdgeProgram: error while creating indicesBuffer"); r.indicesBuffer = n, r.positionLocation = t.getAttribLocation(r.program, "a_position"), r.colorLocation = t.getAttribLocation(r.program, "a_color"), r.normalLocation = t.getAttribLocation(r.program, "a_normal"); var i = t.getUniformLocation(r.program, "u_matrix"); if (null === i) throw new Error("EdgeProgram: error while getting matrixLocation"); r.matrixLocation = i; var o = t.getUniformLocation(r.program, "u_correctionRatio"); if (null === o) throw new Error("EdgeProgram: error while getting correctionRatioLocation"); r.correctionRatioLocation = o; var u = t.getUniformLocation(r.program, "u_sqrtZoomRatio"); if (null === u) throw new Error("EdgeProgram: error while getting sqrtZoomRatioLocation"); return r.sqrtZoomRatioLocation = u, r.canUse32BitsIndices = (0, a.canUse32BitsIndices)(t), r.IndicesArray = r.canUse32BitsIndices ? Uint32Array : Uint16Array, r.indicesArray = new r.IndicesArray, r.indicesType = r.canUse32BitsIndices ? t.UNSIGNED_INT : t.UNSIGNED_SHORT, r.bind(), r } return i(t, e), t.prototype.bind = function () { var e = this.gl; e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indicesBuffer), e.enableVertexAttribArray(this.positionLocation), e.enableVertexAttribArray(this.normalLocation), e.enableVertexAttribArray(this.colorLocation), e.vertexAttribPointer(this.positionLocation, 2, e.FLOAT, !1, 5 * Float32Array.BYTES_PER_ELEMENT, 0), e.vertexAttribPointer(this.normalLocation, 2, e.FLOAT, !1, 5 * Float32Array.BYTES_PER_ELEMENT, 8), e.vertexAttribPointer(this.colorLocation, 4, e.UNSIGNED_BYTE, !0, 5 * Float32Array.BYTES_PER_ELEMENT, 16) }, t.prototype.computeIndices = function () { for (var e = this.array.length / 5, t = e + e / 2, r = new this.IndicesArray(t), n = 0, i = 0; n < e; n += 4)r[i++] = n, r[i++] = n + 1, r[i++] = n + 2, r[i++] = n + 2, r[i++] = n + 1, r[i++] = n + 3; this.indicesArray = r }, t.prototype.bufferData = function () { e.prototype.bufferData.call(this); var t = this.gl; t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indicesArray, t.STATIC_DRAW) }, t.prototype.process = function (e, t, r, n, i) { if (n) for (var o = 20 * i, s = o + 20; o < s; o++)this.array[o] = 0; else { var c = r.size || 1, u = e.x, h = e.y, d = t.x, l = t.y, p = (0, a.floatColor)(r.color), f = d - u, g = l - h, y = f * f + g * g, m = 0, v = 0; y && (m = -g * (y = 1 / Math.sqrt(y)) * c, v = f * y * c); var b = 20 * i, w = this.array; w[b++] = u, w[b++] = h, w[b++] = m, w[b++] = v, w[b++] = p, w[b++] = u, w[b++] = h, w[b++] = -m, w[b++] = -v, w[b++] = p, w[b++] = d, w[b++] = l, w[b++] = m, w[b++] = v, w[b++] = p, w[b++] = d, w[b++] = l, w[b++] = -m, w[b++] = -v, w[b] = p } }, t.prototype.render = function (e) { if (!this.hasNothingToRender()) { var t = this.gl, r = this.program; t.useProgram(r), t.uniformMatrix3fv(this.matrixLocation, !1, e.matrix), t.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(e.ratio)), t.uniform1f(this.correctionRatioLocation, e.correctionRatio), t.drawElements(t.TRIANGLES, this.indicesArray.length, this.indicesType, 0) } }, t }(r(4917).AbstractEdgeProgram); t.default = u }, 8037: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }), o = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); var a = r(4524), s = o(r(146)), c = o(r(4546)), u = function (e) { function t(t) { var r = e.call(this, t, s.default, c.default, 1, 4) || this; return r.bind(), r } return i(t, e), t.prototype.process = function (e, t, r) { var n = this.array, i = 1 * r * 4; if (t) return n[i++] = 0, n[i++] = 0, n[i++] = 0, void (n[i++] = 0); var o = (0, a.floatColor)(e.color); n[i++] = e.x, n[i++] = e.y, n[i++] = e.size, n[i] = o }, t.prototype.render = function (e) { if (!this.hasNothingToRender()) { var t = this.gl, r = this.program; t.useProgram(r), t.uniform1f(this.ratioLocation, 1 / Math.sqrt(e.ratio)), t.uniform1f(this.scaleLocation, e.scalingRatio), t.uniformMatrix3fv(this.matrixLocation, !1, e.matrix), t.drawArrays(t.POINTS, 0, this.array.length / 4) } }, t }(r(3533).AbstractNodeProgram); t.default = u }, 7083: e => { (() => { "use strict"; var t = { d: (e, r) => { for (var n in r) t.o(r, n) && !t.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: r[n] }) }, o: (e, t) => Object.prototype.hasOwnProperty.call(e, t), r: e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) } }, r = {}; t.r(r), t.d(r, { default: () => n }); const n = "precision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n"; e.exports = r })() }, 5191: e => { (() => { "use strict"; var t = { d: (e, r) => { for (var n in r) t.o(r, n) && !t.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: r[n] }) }, o: (e, t) => Object.prototype.hasOwnProperty.call(e, t), r: e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) } }, r = {}; t.r(r), t.d(r, { default: () => n }); const n = "attribute vec2 a_position;\nattribute vec2 a_normal;\nattribute float a_radius;\nattribute vec4 a_color;\nattribute vec3 a_barycentric;\n\nuniform mat3 u_matrix;\nuniform float u_sqrtZoomRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\nconst float arrowHeadWidthLengthRatio = 0.66;\nconst float arrowHeadLengthThicknessRatio = 2.5;\n\nvoid main() {\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl and\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\n  // happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio;\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\n  float adaptedWebGLNodeRadius = a_radius * 2.0 * u_correctionRatio * u_sqrtZoomRatio;\n  float adaptedWebGLArrowHeadLength = adaptedWebGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\n  float adaptedWebGLArrowHeadHalfWidth = adaptedWebGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;\n\n  float da = a_barycentric.x;\n  float db = a_barycentric.y;\n  float dc = a_barycentric.z;\n\n  vec2 delta = vec2(\n      da * (adaptedWebGLNodeRadius * unitNormal.y)\n    + db * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y + adaptedWebGLArrowHeadHalfWidth * unitNormal.x)\n    + dc * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y - adaptedWebGLArrowHeadHalfWidth * unitNormal.x),\n\n      da * (-adaptedWebGLNodeRadius * unitNormal.x)\n    + db * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x + adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\n    + dc * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x - adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\n  );\n\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\n\n  gl_Position = vec4(position, 0, 1);\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n}\n"; e.exports = r })() }, 8073: e => { (() => { "use strict"; var t = { d: (e, r) => { for (var n in r) t.o(r, n) && !t.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: r[n] }) }, o: (e, t) => Object.prototype.hasOwnProperty.call(e, t), r: e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) } }, r = {}; t.r(r), t.d(r, { default: () => n }); const n = "attribute vec4 a_color;\nattribute vec2 a_normal;\nattribute vec2 a_position;\nattribute float a_radius;\n\nuniform mat3 u_matrix;\nuniform float u_sqrtZoomRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\nconst float arrowHeadLengthThicknessRatio = 2.5;\n\nvoid main() {\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl. Please read it to\n  // get better comments on what's happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio;\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\n\n  // Here, we move the point to leave space for the arrow head:\n  float direction = sign(a_radius);\n  float adaptedWebGLNodeRadius = direction * a_radius * 2.0 * u_correctionRatio * u_sqrtZoomRatio;\n  float adaptedWebGLArrowHeadLength = adaptedWebGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\n\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength);\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(a_position + unitNormal * adaptedWebGLThickness + compensationVector, 1)).xy, 0, 1);\n\n  v_thickness = webGLThickness / u_sqrtZoomRatio;\n\n  v_normal = unitNormal;\n  v_color = a_color;\n  v_color.a *= bias;\n}\n"; e.exports = r })() }, 4879: e => { (() => { "use strict"; var t = { d: (e, r) => { for (var n in r) t.o(r, n) && !t.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: r[n] }) }, o: (e, t) => Object.prototype.hasOwnProperty.call(e, t), r: e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) } }, r = {}; t.r(r), t.d(r, { default: () => n }); const n = "precision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float feather = 0.001;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float dist = length(v_normal) * v_thickness;\n\n  float t = smoothstep(\n    v_thickness - feather,\n    v_thickness,\n    dist\n  );\n\n  gl_FragColor = mix(v_color, transparent, t);\n}\n"; e.exports = r })() }, 372: e => { (() => { "use strict"; var t = { d: (e, r) => { for (var n in r) t.o(r, n) && !t.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: r[n] }) }, o: (e, t) => Object.prototype.hasOwnProperty.call(e, t), r: e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) } }, r = {}; t.r(r), t.d(r, { default: () => n }); const n = 'attribute vec4 a_color;\nattribute vec2 a_normal;\nattribute vec2 a_position;\n\nuniform mat3 u_matrix;\nuniform float u_sqrtZoomRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // We require edges to be at least `minThickness` pixels thick *on screen*\n  // (so we need to compensate the SQRT zoom ratio):\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\n\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\n  // referential (in a ([0, 1], [0, 1]) space), using our "magic" correction\n  // ratio:\n  float webGLThickness = pixelsThickness * u_correctionRatio;\n\n  // Finally, we adapt the edge thickness to the "SQRT rule" in sigma (so that\n  // items are not too big when zoomed in, and not too small when zoomed out).\n  // The exact computation should be `adapted = value * zoom / sqrt(zoom)`, but\n  // it\'s simpler like this:\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(a_position + unitNormal * adaptedWebGLThickness, 1)).xy, 0, 1);\n\n  // For the fragment shader though, we need a thickness that takes the "magic"\n  // correction ratio into account (as in webGLThickness), but so that the\n  // antialiasint effect does not depend on the zoom level. So here\'s yet\n  // another thickness version:\n  v_thickness = webGLThickness / u_sqrtZoomRatio;\n\n  v_normal = unitNormal;\n  v_color = a_color;\n  v_color.a *= bias;\n}\n'; e.exports = r })() }, 4546: e => { (() => { "use strict"; var t = { d: (e, r) => { for (var n in r) t.o(r, n) && !t.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: r[n] }) }, o: (e, t) => Object.prototype.hasOwnProperty.call(e, t), r: e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) } }, r = {}; t.r(r), t.d(r, { default: () => n }); const n = "precision mediump float;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float radius = 0.5;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\n  float dist = radius - length(m);\n\n  float t = 0.0;\n  if (dist > v_border)\n    t = 1.0;\n  else if (dist > 0.0)\n    t = dist / v_border;\n\n  gl_FragColor = mix(transparent, v_color, t);\n}\n"; e.exports = r })() }, 146: e => { (() => { "use strict"; var t = { d: (e, r) => { for (var n in r) t.o(r, n) && !t.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: r[n] }) }, o: (e, t) => Object.prototype.hasOwnProperty.call(e, t), r: e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) } }, r = {}; t.r(r), t.d(r, { default: () => n }); const n = "attribute vec2 a_position;\nattribute float a_size;\nattribute vec4 a_color;\n\nuniform float u_ratio;\nuniform float u_scale;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\n\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n}\n"; e.exports = r })() }, 1538: (e, t) => { "use strict"; function r(e, t, r) { var n = "VERTEX" === e ? t.VERTEX_SHADER : t.FRAGMENT_SHADER, i = t.createShader(n); if (null === i) throw new Error("loadShader: error while creating the shader"); if (t.shaderSource(i, r), t.compileShader(i), !t.getShaderParameter(i, t.COMPILE_STATUS)) { var o = t.getShaderInfoLog(i); throw t.deleteShader(i), new Error("loadShader: error while compiling the shader:\n".concat(o, "\n").concat(r)) } return i } Object.defineProperty(t, "__esModule", { value: !0 }), t.loadProgram = t.loadFragmentShader = t.loadVertexShader = void 0, t.loadVertexShader = function (e, t) { return r("VERTEX", e, t) }, t.loadFragmentShader = function (e, t) { return r("FRAGMENT", e, t) }, t.loadProgram = function (e, t) { var r, n, i = e.createProgram(); if (null === i) throw new Error("loadProgram: error while creating the program."); for (r = 0, n = t.length; r < n; r++)e.attachShader(i, t[r]); if (e.linkProgram(i), !e.getProgramParameter(i, e.LINK_STATUS)) throw e.deleteProgram(i), new Error("loadProgram: error while linking the program."); return i } }, 6482: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.DEFAULT_SETTINGS = t.validateSettings = void 0; var i = n(r(4577)), o = n(r(4607)), a = n(r(2294)), s = n(r(8037)), c = n(r(5857)), u = n(r(4638)); t.validateSettings = function (e) { if ("number" != typeof e.labelDensity || e.labelDensity < 0) throw new Error("Settings: invalid `labelDensity`. Expecting a positive number."); var t = e.minCameraRatio, r = e.maxCameraRatio; if ("number" == typeof t && "number" == typeof r && r < t) throw new Error("Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`.") }, t.DEFAULT_SETTINGS = { hideEdgesOnMove: !1, hideLabelsOnMove: !1, renderLabels: !0, renderEdgeLabels: !1, enableEdgeClickEvents: !1, enableEdgeWheelEvents: !1, enableEdgeHoverEvents: !1, defaultNodeColor: "#999", defaultNodeType: "circle", defaultEdgeColor: "#ccc", defaultEdgeType: "line", labelFont: "Arial", labelSize: 14, labelWeight: "normal", labelColor: { color: "#000" }, edgeLabelFont: "Arial", edgeLabelSize: 14, edgeLabelWeight: "normal", edgeLabelColor: { attribute: "color" }, stagePadding: 30, labelDensity: 1, labelGridCellSize: 100, labelRenderedSizeThreshold: 6, nodeReducer: null, edgeReducer: null, zIndex: !1, minCameraRatio: null, maxCameraRatio: null, labelRenderer: i.default, hoverRenderer: o.default, edgeLabelRenderer: a.default, allowInvalidContainer: !1, nodeProgramClasses: { circle: s.default }, edgeProgramClasses: { arrow: u.default, line: c.default } } }, 248: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }), o = this && this.__assign || function () { return o = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++)for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }, o.apply(this, arguments) }, a = this && this.__values || function (e) { var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, s = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); var c = s(r(7554)), u = s(r(9886)), h = s(r(1461)), d = r(3291), l = r(4524), p = r(8098), f = r(6482), g = s(r(9311)), y = r(5132), m = r(9822); function v(e, t, r) { if (!r.hasOwnProperty("x") || !r.hasOwnProperty("y")) throw new Error('Sigma: could not find a valid position (x, y) for node "'.concat(t, '". All your nodes must have a number "x" and "y". Maybe your forgot to apply a layout or your "nodeReducer" is not returning the correct data?')); return r.color || (r.color = e.defaultNodeColor), r.label || "" === r.label || (r.label = null), void 0 !== r.label && null !== r.label ? r.label = "" + r.label : r.label = null, r.size || (r.size = 2), r.hasOwnProperty("hidden") || (r.hidden = !1), r.hasOwnProperty("highlighted") || (r.highlighted = !1), r.hasOwnProperty("forceLabel") || (r.forceLabel = !1), r.type && "" !== r.type || (r.type = e.defaultNodeType), r.zIndex || (r.zIndex = 0), r } function b(e, t, r) { return r.color || (r.color = e.defaultEdgeColor), r.label || (r.label = ""), r.size || (r.size = .5), r.hasOwnProperty("hidden") || (r.hidden = !1), r.hasOwnProperty("forceLabel") || (r.forceLabel = !1), r.type && "" !== r.type || (r.type = e.defaultEdgeType), r.zIndex || (r.zIndex = 0), r } var w = function (e) { function t(t, r, n) { void 0 === n && (n = {}); var i = e.call(this) || this; if (i.elements = {}, i.canvasContexts = {}, i.webGLContexts = {}, i.activeListeners = {}, i.quadtree = new h.default, i.labelGrid = new p.LabelGrid, i.nodeDataCache = {}, i.edgeDataCache = {}, i.nodesWithForcedLabels = [], i.edgesWithForcedLabels = [], i.nodeExtent = { x: [0, 1], y: [0, 1] }, i.matrix = (0, y.identity)(), i.invMatrix = (0, y.identity)(), i.correctionRatio = 1, i.customBBox = null, i.normalizationFunction = (0, l.createNormalizationFunction)({ x: [0, 1], y: [0, 1] }), i.cameraSizeRatio = 1, i.width = 0, i.height = 0, i.pixelRatio = (0, l.getPixelRatio)(), i.displayedLabels = new Set, i.highlightedNodes = new Set, i.hoveredNode = null, i.hoveredEdge = null, i.renderFrame = null, i.renderHighlightedNodesFrame = null, i.needToProcess = !1, i.needToSoftProcess = !1, i.checkEdgesEventsFrame = null, i.nodePrograms = {}, i.hoverNodePrograms = {}, i.edgePrograms = {}, i.settings = (0, l.assign)({}, f.DEFAULT_SETTINGS, n), (0, f.validateSettings)(i.settings), (0, l.validateGraph)(t), !(r instanceof HTMLElement)) throw new Error("Sigma: container should be an html element."); for (var o in i.graph = t, i.container = r, i.createWebGLContext("edges", { preserveDrawingBuffer: !0 }), i.createCanvasContext("edgeLabels"), i.createWebGLContext("nodes"), i.createCanvasContext("labels"), i.createCanvasContext("hovers"), i.createWebGLContext("hoverNodes"), i.createCanvasContext("mouse"), i.webGLContexts) { var a = i.webGLContexts[o]; a.blendFunc(a.ONE, a.ONE_MINUS_SRC_ALPHA), a.enable(a.BLEND) } for (var s in i.settings.nodeProgramClasses) { var d = i.settings.nodeProgramClasses[s]; i.nodePrograms[s] = new d(i.webGLContexts.nodes, i), i.hoverNodePrograms[s] = new d(i.webGLContexts.hoverNodes, i) } for (var s in i.settings.edgeProgramClasses) { var m = i.settings.edgeProgramClasses[s]; i.edgePrograms[s] = new m(i.webGLContexts.edges, i) } return i.resize(), i.camera = new c.default, i.bindCameraHandlers(), i.mouseCaptor = new u.default(i.elements.mouse, i), i.touchCaptor = new g.default(i.elements.mouse, i), i.bindEventHandlers(), i.bindGraphHandlers(), i.handleSettingsUpdate(), i.process(), i.render(), i } return i(t, e), t.prototype.createCanvas = function (e) { var t = (0, l.createElement)("canvas", { position: "absolute" }, { class: "sigma-".concat(e) }); return this.elements[e] = t, this.container.appendChild(t), t }, t.prototype.createCanvasContext = function (e) { var t = this.createCanvas(e); return this.canvasContexts[e] = t.getContext("2d", { preserveDrawingBuffer: !1, antialias: !1 }), this }, t.prototype.createWebGLContext = function (e, t) { var r, n = this.createCanvas(e), i = o({ preserveDrawingBuffer: !1, antialias: !1 }, t || {}); return (r = n.getContext("webgl2", i)) || (r = n.getContext("webgl", i)), r || (r = n.getContext("experimental-webgl", i)), this.webGLContexts[e] = r, this }, t.prototype.bindCameraHandlers = function () { var e = this; return this.activeListeners.camera = function () { e._scheduleRefresh() }, this.camera.on("updated", this.activeListeners.camera), this }, t.prototype.mouseIsOnNode = function (e, t, r) { var n = e.x, i = e.y, o = t.x, a = t.y; return n > o - r && n < o + r && i > a - r && i < a + r && Math.sqrt(Math.pow(n - o, 2) + Math.pow(i - a, 2)) < r }, t.prototype.getQuadNodes = function (e) { var t = this.viewportToFramedGraph(e); return this.quadtree.point(t.x, 1 - t.y) }, t.prototype.getNodeAtPosition = function (e) { for (var t = e.x, r = e.y, n = this.getQuadNodes(e), i = 1 / 0, o = null, a = 0, s = n.length; a < s; a++) { var c = n[a], u = this.nodeDataCache[c], h = this.framedGraphToViewport(u), d = this.scaleSize(u.size); if (!u.hidden && this.mouseIsOnNode(e, h, d)) { var l = Math.sqrt(Math.pow(t - h.x, 2) + Math.pow(r - h.y, 2)); l < i && (i = l, o = c) } } return o }, t.prototype.bindEventHandlers = function () { var e = this; this.activeListeners.handleResize = function () { e.needToSoftProcess = !0, e._scheduleRefresh() }, window.addEventListener("resize", this.activeListeners.handleResize), this.activeListeners.handleMove = function (t) { var r = { event: t, preventSigmaDefault: function () { t.preventSigmaDefault() } }, n = e.getNodeAtPosition(t); if (n && e.hoveredNode !== n && !e.nodeDataCache[n].hidden) return e.hoveredNode && e.emit("leaveNode", o(o({}, r), { node: e.hoveredNode })), e.hoveredNode = n, e.emit("enterNode", o(o({}, r), { node: n })), void e.scheduleHighlightedNodesRender(); if (e.hoveredNode) { var i = e.nodeDataCache[e.hoveredNode], a = e.framedGraphToViewport(i), s = e.scaleSize(i.size); if (!e.mouseIsOnNode(t, a, s)) { var c = e.hoveredNode; return e.hoveredNode = null, e.emit("leaveNode", o(o({}, r), { node: c })), void e.scheduleHighlightedNodesRender() } } !0 === e.settings.enableEdgeHoverEvents ? e.checkEdgeHoverEvents(r) : "debounce" === e.settings.enableEdgeHoverEvents && (e.checkEdgesEventsFrame || (e.checkEdgesEventsFrame = (0, l.requestFrame)((function () { e.checkEdgeHoverEvents(r), e.checkEdgesEventsFrame = null })))) }; var t = function (t) { return function (r) { var n = { event: r, preventSigmaDefault: function () { r.preventSigmaDefault() } }, i = r.original.isFakeSigmaMouseEvent ? e.getNodeAtPosition(r) : e.hoveredNode; if (i) return e.emit("".concat(t, "Node"), o(o({}, n), { node: i })); if ("wheel" === t ? e.settings.enableEdgeWheelEvents : e.settings.enableEdgeClickEvents) { var a = e.getEdgeAtPoint(r.x, r.y); if (a) return e.emit("".concat(t, "Edge"), o(o({}, n), { edge: a })) } return e.emit("".concat(t, "Stage"), n) } }; return this.activeListeners.handleClick = t("click"), this.activeListeners.handleRightClick = t("rightClick"), this.activeListeners.handleDoubleClick = t("doubleClick"), this.activeListeners.handleWheel = t("wheel"), this.activeListeners.handleDown = t("down"), this.mouseCaptor.on("mousemove", this.activeListeners.handleMove), this.mouseCaptor.on("click", this.activeListeners.handleClick), this.mouseCaptor.on("rightClick", this.activeListeners.handleRightClick), this.mouseCaptor.on("doubleClick", this.activeListeners.handleDoubleClick), this.mouseCaptor.on("wheel", this.activeListeners.handleWheel), this.mouseCaptor.on("mousedown", this.activeListeners.handleDown), this }, t.prototype.bindGraphHandlers = function () { var e = this, t = this.graph; return this.activeListeners.graphUpdate = function () { e.needToProcess = !0, e._scheduleRefresh() }, this.activeListeners.softGraphUpdate = function () { e.needToSoftProcess = !0, e._scheduleRefresh() }, this.activeListeners.dropNodeGraphUpdate = function (t) { delete e.nodeDataCache[t.key], e.hoveredNode === t.key && (e.hoveredNode = null), e.activeListeners.graphUpdate() }, this.activeListeners.dropEdgeGraphUpdate = function (t) { delete e.edgeDataCache[t.key], e.hoveredEdge === t.key && (e.hoveredEdge = null), e.activeListeners.graphUpdate() }, this.activeListeners.clearEdgesGraphUpdate = function () { e.edgeDataCache = {}, e.hoveredEdge = null, e.activeListeners.graphUpdate() }, this.activeListeners.clearGraphUpdate = function () { e.nodeDataCache = {}, e.hoveredNode = null, e.activeListeners.clearEdgesGraphUpdate() }, t.on("nodeAdded", this.activeListeners.graphUpdate), t.on("nodeDropped", this.activeListeners.dropNodeGraphUpdate), t.on("nodeAttributesUpdated", this.activeListeners.softGraphUpdate), t.on("eachNodeAttributesUpdated", this.activeListeners.graphUpdate), t.on("edgeAdded", this.activeListeners.graphUpdate), t.on("edgeDropped", this.activeListeners.dropEdgeGraphUpdate), t.on("edgeAttributesUpdated", this.activeListeners.softGraphUpdate), t.on("eachEdgeAttributesUpdated", this.activeListeners.graphUpdate), t.on("edgesCleared", this.activeListeners.clearEdgesGraphUpdate), t.on("cleared", this.activeListeners.clearGraphUpdate), this }, t.prototype.checkEdgeHoverEvents = function (e) { var t = this.hoveredNode ? null : this.getEdgeAtPoint(e.event.x, e.event.y); return t !== this.hoveredEdge && (this.hoveredEdge && this.emit("leaveEdge", o(o({}, e), { edge: this.hoveredEdge })), t && this.emit("enterEdge", o(o({}, e), { edge: t })), this.hoveredEdge = t), this }, t.prototype.getEdgeAtPoint = function (e, t) { var r, n, i = this, o = this.edgeDataCache, s = this.nodeDataCache; if (!(0, m.isPixelColored)(this.webGLContexts.edges, e * this.pixelRatio, t * this.pixelRatio)) return null; var c = this.viewportToGraph({ x: e, y: t }), u = c.x, h = c.y, d = 0; if (this.graph.someEdge((function (e, t, r, n, a, c) { var u = a.x, h = a.y, l = c.x, p = c.y; if (o[e].hidden || s[r].hidden || s[n].hidden) return !1; if (u !== l || h !== p) { var f = Math.sqrt(Math.pow(l - u, 2) + Math.pow(p - h, 2)), g = i.graphToViewport({ x: u, y: h }), y = g.x, m = g.y, v = i.graphToViewport({ x: l, y: p }), b = v.x, w = v.y, _ = Math.sqrt(Math.pow(b - y, 2) + Math.pow(w - m, 2)); return d = f / _, !0 } })), !d) return null; var l = this.graph.filterEdges((function (e, t, r, n, a, c) { return !(o[e].hidden || s[r].hidden || s[n].hidden) && (!!(0, m.doEdgeCollideWithPoint)(u, h, a.x, a.y, c.x, c.y, o[e].size * d / i.cameraSizeRatio) || void 0) })); if (0 === l.length) return null; var p = l[l.length - 1], f = -1 / 0; try { for (var g = a(l), y = g.next(); !y.done; y = g.next()) { var v = y.value, b = this.graph.getEdgeAttribute(v, "zIndex"); b >= f && (p = v, f = b) } } catch (e) { r = { error: e } } finally { try { y && !y.done && (n = g.return) && n.call(g) } finally { if (r) throw r.error } } return p }, t.prototype.process = function (e) { var t = this; void 0 === e && (e = !1); var r = this.graph, n = this.settings, i = this.getDimensions(), o = [1 / 0, -1 / 0], a = [1 / 0, -1 / 0]; this.quadtree.clear(), this.labelGrid.resizeAndClear(i, n.labelGridCellSize), this.highlightedNodes = new Set, this.nodeExtent = (0, l.graphExtent)(r), this.nodesWithForcedLabels = [], this.edgesWithForcedLabels = []; var s = new c.default, u = (0, l.matrixFromCamera)(s.getState(), this.getDimensions(), this.getGraphDimensions(), this.getSetting("stagePadding") || 0); this.normalizationFunction = (0, l.createNormalizationFunction)(this.customBBox || this.nodeExtent); for (var h = {}, d = r.nodes(), p = 0, f = d.length; p < f; p++) { var g = d[p], y = Object.assign({}, r.getNodeAttributes(g)); n.nodeReducer && (y = n.nodeReducer(g, y)), h[(w = v(this.settings, g, y)).type] = (h[w.type] || 0) + 1, this.nodeDataCache[g] = w, this.normalizationFunction.applyTo(w), w.forceLabel && this.nodesWithForcedLabels.push(g), this.settings.zIndex && (w.zIndex < o[0] && (o[0] = w.zIndex), w.zIndex > o[1] && (o[1] = w.zIndex)) } for (var m in this.nodePrograms) { if (!this.nodePrograms.hasOwnProperty(m)) throw new Error('Sigma: could not find a suitable program for node type "'.concat(m, '"!')); e || this.nodePrograms[m].allocate(h[m] || 0), h[m] = 0 } for (this.settings.zIndex && o[0] !== o[1] && (d = (0, l.zIndexOrdering)(o, (function (e) { return t.nodeDataCache[e].zIndex }), d)), p = 0, f = d.length; p < f; p++) { g = d[p]; var w = this.nodeDataCache[g]; this.quadtree.add(g, w.x, 1 - w.y, w.size / this.width), "string" != typeof w.label || w.hidden || this.labelGrid.add(g, w.size, this.framedGraphToViewport(w, { matrix: u })), this.nodePrograms[w.type].process(w, w.hidden, h[w.type]++), w.highlighted && !w.hidden && this.highlightedNodes.add(g) } this.labelGrid.organize(); var _ = {}, x = r.edges(); for (p = 0, f = x.length; p < f; p++) { var E = x[p]; y = Object.assign({}, r.getEdgeAttributes(E)), n.edgeReducer && (y = n.edgeReducer(E, y)), _[(w = b(this.settings, 0, y)).type] = (_[w.type] || 0) + 1, this.edgeDataCache[E] = w, w.forceLabel && !w.hidden && this.edgesWithForcedLabels.push(E), this.settings.zIndex && (w.zIndex < a[0] && (a[0] = w.zIndex), w.zIndex > a[1] && (a[1] = w.zIndex)) } for (var m in this.edgePrograms) { if (!this.edgePrograms.hasOwnProperty(m)) throw new Error('Sigma: could not find a suitable program for edge type "'.concat(m, '"!')); e || this.edgePrograms[m].allocate(_[m] || 0), _[m] = 0 } for (this.settings.zIndex && a[0] !== a[1] && (x = (0, l.zIndexOrdering)(a, (function (e) { return t.edgeDataCache[e].zIndex }), x)), p = 0, f = x.length; p < f; p++) { E = x[p], w = this.edgeDataCache[E]; var C = r.extremities(E), k = this.nodeDataCache[C[0]], L = this.nodeDataCache[C[1]], A = w.hidden || k.hidden || L.hidden; this.edgePrograms[w.type].process(k, L, w, A, _[w.type]++) } for (var m in this.edgePrograms) { var S = this.edgePrograms[m]; e || "function" != typeof S.computeIndices || S.computeIndices() } return this }, t.prototype.handleSettingsUpdate = function () { return this.camera.minRatio = this.settings.minCameraRatio, this.camera.maxRatio = this.settings.maxCameraRatio, this.camera.setState(this.camera.validateState(this.camera.getState())), this }, t.prototype._refresh = function () { return this.needToProcess ? this.process() : this.needToSoftProcess && this.process(!0), this.needToProcess = !1, this.needToSoftProcess = !1, this.render(), this }, t.prototype._scheduleRefresh = function () { var e = this; return this.renderFrame || (this.renderFrame = (0, l.requestFrame)((function () { e._refresh(), e.renderFrame = null }))), this }, t.prototype.renderLabels = function () { if (!this.settings.renderLabels) return this; var e, t = this.camera.getState(); if (t.ratio >= 1) e = new Set(this.graph.nodes()); else { var r = this.viewRectangle(); e = new Set(this.quadtree.rectangle(r.x1, 1 - r.y1, r.x2, 1 - r.y2, r.height)) } var n = this.labelGrid.getLabelsToDisplay(t.ratio, this.settings.labelDensity).concat(this.nodesWithForcedLabels); this.displayedLabels = new Set; for (var i = this.canvasContexts.labels, a = 0, s = n.length; a < s; a++) { var c = n[a], u = this.nodeDataCache[c]; if (!this.displayedLabels.has(c) && !u.hidden) { var h = this.framedGraphToViewport(u), d = h.x, l = h.y, p = this.scaleSize(u.size); !u.forceLabel && p < this.settings.labelRenderedSizeThreshold || e.has(c) && (this.displayedLabels.add(c), this.settings.labelRenderer(i, o(o({ key: c }, u), { size: p, x: d, y: l }), this.settings)) } } return this }, t.prototype.renderEdgeLabels = function () { if (!this.settings.renderEdgeLabels) return this; var e = this.canvasContexts.edgeLabels; e.clearRect(0, 0, this.width, this.height); for (var t = (0, p.edgeLabelsToDisplayFromNodes)({ graph: this.graph, hoveredNode: this.hoveredNode, displayedNodeLabels: this.displayedLabels, highlightedNodes: this.highlightedNodes }).concat(this.edgesWithForcedLabels), r = new Set, n = 0, i = t.length; n < i; n++) { var a = t[n], s = this.graph.extremities(a), c = this.nodeDataCache[s[0]], u = this.nodeDataCache[s[1]], h = this.edgeDataCache[a]; r.has(a) || h.hidden || c.hidden || u.hidden || (this.settings.edgeLabelRenderer(e, o(o({ key: a }, h), { size: this.scaleSize(h.size) }), o(o(o({ key: s[0] }, c), this.framedGraphToViewport(c)), { size: this.scaleSize(c.size) }), o(o(o({ key: s[1] }, u), this.framedGraphToViewport(u)), { size: this.scaleSize(u.size) }), this.settings), r.add(a)) } return this }, t.prototype.renderHighlightedNodes = function () { var e = this, t = this.canvasContexts.hovers; t.clearRect(0, 0, this.width, this.height); var r = []; this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden && r.push(this.hoveredNode), this.highlightedNodes.forEach((function (t) { t !== e.hoveredNode && r.push(t) })), r.forEach((function (r) { return function (r) { var n = e.nodeDataCache[r], i = e.framedGraphToViewport(n), a = i.x, s = i.y, c = e.scaleSize(n.size); e.settings.hoverRenderer(t, o(o({ key: r }, n), { size: c, x: a, y: s }), e.settings) }(r) })); var n = {}; for (var i in r.forEach((function (t) { var r = e.nodeDataCache[t].type; n[r] = (n[r] || 0) + 1 })), this.hoverNodePrograms) this.hoverNodePrograms[i].allocate(n[i] || 0), n[i] = 0; for (var i in r.forEach((function (t) { var r = e.nodeDataCache[t]; e.hoverNodePrograms[r.type].process(r, r.hidden, n[r.type]++) })), this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT), this.hoverNodePrograms) { var a = this.hoverNodePrograms[i]; a.bind(), a.bufferData(), a.render({ matrix: this.matrix, width: this.width, height: this.height, ratio: this.camera.ratio, correctionRatio: this.correctionRatio / this.camera.ratio, scalingRatio: this.pixelRatio }) } }, t.prototype.scheduleHighlightedNodesRender = function () { var e = this; this.renderHighlightedNodesFrame || this.renderFrame || (this.renderHighlightedNodesFrame = (0, l.requestFrame)((function () { e.renderHighlightedNodesFrame = null, e.renderHighlightedNodes(), e.renderEdgeLabels() }))) }, t.prototype.render = function () { var e = this; this.emit("beforeRender"); var t = function () { return e.emit("afterRender"), e }; if (this.renderFrame && ((0, l.cancelFrame)(this.renderFrame), this.renderFrame = null, this.needToProcess = !1, this.needToSoftProcess = !1), this.resize(), this.clear(), this.updateCachedValues(), !this.graph.order) return t(); var r = this.mouseCaptor, n = this.camera.isAnimated() || r.isMoving || r.draggedEvents || r.currentWheelDirection, i = this.camera.getState(), o = this.getDimensions(), a = this.getGraphDimensions(), s = this.getSetting("stagePadding") || 0; for (var c in this.matrix = (0, l.matrixFromCamera)(i, o, a, s), this.invMatrix = (0, l.matrixFromCamera)(i, o, a, s, !0), this.correctionRatio = (0, l.getMatrixImpact)(this.matrix, i, o), this.nodePrograms) (u = this.nodePrograms[c]).bind(), u.bufferData(), u.render({ matrix: this.matrix, width: this.width, height: this.height, ratio: i.ratio, correctionRatio: this.correctionRatio / i.ratio, scalingRatio: this.pixelRatio }); if (!this.settings.hideEdgesOnMove || !n) for (var c in this.edgePrograms) { var u; (u = this.edgePrograms[c]).bind(), u.bufferData(), u.render({ matrix: this.matrix, width: this.width, height: this.height, ratio: i.ratio, correctionRatio: this.correctionRatio / i.ratio, scalingRatio: this.pixelRatio }) } return this.settings.hideLabelsOnMove && n || (this.renderLabels(), this.renderEdgeLabels(), this.renderHighlightedNodes()), t() }, t.prototype.updateCachedValues = function () { var e = this.camera.getState().ratio; this.cameraSizeRatio = Math.sqrt(e) }, t.prototype.getCamera = function () { return this.camera }, t.prototype.getContainer = function () { return this.container }, t.prototype.getGraph = function () { return this.graph }, t.prototype.getMouseCaptor = function () { return this.mouseCaptor }, t.prototype.getTouchCaptor = function () { return this.touchCaptor }, t.prototype.getDimensions = function () { return { width: this.width, height: this.height } }, t.prototype.getGraphDimensions = function () { var e = this.customBBox || this.nodeExtent; return { width: e.x[1] - e.x[0] || 1, height: e.y[1] - e.y[0] || 1 } }, t.prototype.getNodeDisplayData = function (e) { var t = this.nodeDataCache[e]; return t ? Object.assign({}, t) : void 0 }, t.prototype.getEdgeDisplayData = function (e) { var t = this.edgeDataCache[e]; return t ? Object.assign({}, t) : void 0 }, t.prototype.getSettings = function () { return o({}, this.settings) }, t.prototype.getSetting = function (e) { return this.settings[e] }, t.prototype.setSetting = function (e, t) { return this.settings[e] = t, (0, f.validateSettings)(this.settings), this.handleSettingsUpdate(), this.needToProcess = !0, this._scheduleRefresh(), this }, t.prototype.updateSetting = function (e, t) { return this.settings[e] = t(this.settings[e]), (0, f.validateSettings)(this.settings), this.handleSettingsUpdate(), this.needToProcess = !0, this._scheduleRefresh(), this }, t.prototype.resize = function () { var e = this.width, t = this.height; if (this.width = this.container.offsetWidth, this.height = this.container.offsetHeight, this.pixelRatio = (0, l.getPixelRatio)(), 0 === this.width) { if (!this.settings.allowInvalidContainer) throw new Error("Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seing this error."); this.width = 1 } if (0 === this.height) { if (!this.settings.allowInvalidContainer) throw new Error("Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seing this error."); this.height = 1 } if (e === this.width && t === this.height) return this; for (var r in this.emit("resize"), this.elements) { var n = this.elements[r]; n.style.width = this.width + "px", n.style.height = this.height + "px" } for (var r in this.canvasContexts) this.elements[r].setAttribute("width", this.width * this.pixelRatio + "px"), this.elements[r].setAttribute("height", this.height * this.pixelRatio + "px"), 1 !== this.pixelRatio && this.canvasContexts[r].scale(this.pixelRatio, this.pixelRatio); for (var r in this.webGLContexts) this.elements[r].setAttribute("width", this.width * this.pixelRatio + "px"), this.elements[r].setAttribute("height", this.height * this.pixelRatio + "px"), this.webGLContexts[r].viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio); return this }, t.prototype.clear = function () { return this.webGLContexts.nodes.clear(this.webGLContexts.nodes.COLOR_BUFFER_BIT), this.webGLContexts.edges.clear(this.webGLContexts.edges.COLOR_BUFFER_BIT), this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT), this.canvasContexts.labels.clearRect(0, 0, this.width, this.height), this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height), this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height), this }, t.prototype.refresh = function () { return this.needToProcess = !0, this._refresh(), this }, t.prototype.scheduleRefresh = function () { return this.needToProcess = !0, this._scheduleRefresh(), this }, t.prototype.getViewportZoomedState = function (e, t) { var r = this.camera.getState(), n = r.ratio, i = r.angle, o = r.x, a = r.y, s = t / n, c = { x: this.width / 2, y: this.height / 2 }, u = this.viewportToFramedGraph(e), h = this.viewportToFramedGraph(c); return { angle: i, x: (u.x - h.x) * (1 - s) + o, y: (u.y - h.y) * (1 - s) + a, ratio: t } }, t.prototype.viewRectangle = function () { var e = 0 * this.width / 8, t = 0 * this.height / 8, r = this.viewportToFramedGraph({ x: 0 - e, y: 0 - t }), n = this.viewportToFramedGraph({ x: this.width + e, y: 0 - t }), i = this.viewportToFramedGraph({ x: 0, y: this.height + t }); return { x1: r.x, y1: r.y, x2: n.x, y2: n.y, height: n.y - i.y } }, t.prototype.framedGraphToViewport = function (e, t) { void 0 === t && (t = {}); var r = !!t.cameraState || !!t.viewportDimensions || !!t.graphDimensions, n = t.matrix ? t.matrix : r ? (0, l.matrixFromCamera)(t.cameraState || this.camera.getState(), t.viewportDimensions || this.getDimensions(), t.graphDimensions || this.getGraphDimensions(), t.padding || this.getSetting("stagePadding") || 0) : this.matrix, i = (0, y.multiplyVec2)(n, e); return { x: (1 + i.x) * this.width / 2, y: (1 - i.y) * this.height / 2 } }, t.prototype.viewportToFramedGraph = function (e, t) { void 0 === t && (t = {}); var r = !!t.cameraState || !!t.viewportDimensions || !t.graphDimensions, n = t.matrix ? t.matrix : r ? (0, l.matrixFromCamera)(t.cameraState || this.camera.getState(), t.viewportDimensions || this.getDimensions(), t.graphDimensions || this.getGraphDimensions(), t.padding || this.getSetting("stagePadding") || 0, !0) : this.invMatrix, i = (0, y.multiplyVec2)(n, { x: e.x / this.width * 2 - 1, y: 1 - e.y / this.height * 2 }); return isNaN(i.x) && (i.x = 0), isNaN(i.y) && (i.y = 0), i }, t.prototype.viewportToGraph = function (e, t) { return void 0 === t && (t = {}), this.normalizationFunction.inverse(this.viewportToFramedGraph(e, t)) }, t.prototype.graphToViewport = function (e, t) { return void 0 === t && (t = {}), this.framedGraphToViewport(this.normalizationFunction(e), t) }, t.prototype.getBBox = function () { return (0, l.graphExtent)(this.graph) }, t.prototype.getCustomBBox = function () { return this.customBBox }, t.prototype.setCustomBBox = function (e) { return this.customBBox = e, this._scheduleRefresh(), this }, t.prototype.kill = function () { var e = this.graph; this.emit("kill"), this.removeAllListeners(), this.camera.removeListener("updated", this.activeListeners.camera), window.removeEventListener("resize", this.activeListeners.handleResize), this.mouseCaptor.kill(), this.touchCaptor.kill(), e.removeListener("nodeAdded", this.activeListeners.dropNodeGraphUpdate), e.removeListener("nodeDropped", this.activeListeners.graphUpdate), e.removeListener("nodeAttributesUpdated", this.activeListeners.softGraphUpdate), e.removeListener("eachNodeAttributesUpdated", this.activeListeners.graphUpdate), e.removeListener("edgeAdded", this.activeListeners.graphUpdate), e.removeListener("edgeDropped", this.activeListeners.dropEdgeGraphUpdate), e.removeListener("edgeAttributesUpdated", this.activeListeners.softGraphUpdate), e.removeListener("eachEdgeAttributesUpdated", this.activeListeners.graphUpdate), e.removeListener("edgesCleared", this.activeListeners.clearEdgesGraphUpdate), e.removeListener("cleared", this.activeListeners.clearGraphUpdate), this.quadtree = new h.default, this.nodeDataCache = {}, this.edgeDataCache = {}, this.nodesWithForcedLabels = [], this.edgesWithForcedLabels = [], this.highlightedNodes.clear(), this.renderFrame && ((0, l.cancelFrame)(this.renderFrame), this.renderFrame = null), this.renderHighlightedNodesFrame && ((0, l.cancelFrame)(this.renderHighlightedNodesFrame), this.renderHighlightedNodesFrame = null); for (var t = this.container; t.firstChild;)t.removeChild(t.firstChild) }, t.prototype.scaleSize = function (e) { return e / this.cameraSizeRatio }, t.prototype.getCanvases = function () { return o({}, this.elements) }, t }(d.TypedEventEmitter); t.default = w }, 3291: function (e, t, r) { "use strict"; var n, i = this && this.__extends || (n = function (e, t) { return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, n(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }); Object.defineProperty(t, "__esModule", { value: !0 }), t.TypedEventEmitter = void 0; var o = function (e) { function t() { var t = e.call(this) || this; return t.rawEmitter = t, t } return i(t, e), t }(r(7187).EventEmitter); t.TypedEventEmitter = o }, 5227: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.animateNodes = t.ANIMATE_DEFAULTS = void 0; var i = r(4524), o = n(r(8941)); t.ANIMATE_DEFAULTS = { easing: "quadraticInOut", duration: 150 }, t.animateNodes = function (e, r, n, a) { var s = Object.assign({}, t.ANIMATE_DEFAULTS, n), c = "function" == typeof s.easing ? s.easing : o.default[s.easing], u = Date.now(), h = {}; for (var d in r) { var l = r[d]; for (var p in h[d] = {}, l) h[d][p] = e.getNodeAttribute(d, p) } var f = null, g = function () { f = null; var t = (Date.now() - u) / s.duration; if (t >= 1) { for (var n in r) { var o = r[n]; for (var d in o) e.setNodeAttribute(n, d, o[d]) } "function" == typeof a && a() } else { for (var n in t = c(t), r) { o = r[n]; var l = h[n]; for (var d in o) e.setNodeAttribute(n, d, o[d] * t + l[d] * (1 - t)) } f = (0, i.requestFrame)(g) } }; return g(), function () { f && (0, i.cancelFrame)(f) } } }, 8109: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.HTML_COLORS = void 0, t.HTML_COLORS = { black: "#000000", silver: "#C0C0C0", gray: "#808080", grey: "#808080", white: "#FFFFFF", maroon: "#800000", red: "#FF0000", purple: "#800080", fuchsia: "#FF00FF", green: "#008000", lime: "#00FF00", olive: "#808000", yellow: "#FFFF00", navy: "#000080", blue: "#0000FF", teal: "#008080", aqua: "#00FFFF", darkblue: "#00008B", mediumblue: "#0000CD", darkgreen: "#006400", darkcyan: "#008B8B", deepskyblue: "#00BFFF", darkturquoise: "#00CED1", mediumspringgreen: "#00FA9A", springgreen: "#00FF7F", cyan: "#00FFFF", midnightblue: "#191970", dodgerblue: "#1E90FF", lightseagreen: "#20B2AA", forestgreen: "#228B22", seagreen: "#2E8B57", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", limegreen: "#32CD32", mediumseagreen: "#3CB371", turquoise: "#40E0D0", royalblue: "#4169E1", steelblue: "#4682B4", darkslateblue: "#483D8B", mediumturquoise: "#48D1CC", indigo: "#4B0082", darkolivegreen: "#556B2F", cadetblue: "#5F9EA0", cornflowerblue: "#6495ED", rebeccapurple: "#663399", mediumaquamarine: "#66CDAA", dimgray: "#696969", dimgrey: "#696969", slateblue: "#6A5ACD", olivedrab: "#6B8E23", slategray: "#708090", slategrey: "#708090", lightslategray: "#778899", lightslategrey: "#778899", mediumslateblue: "#7B68EE", lawngreen: "#7CFC00", chartreuse: "#7FFF00", aquamarine: "#7FFFD4", skyblue: "#87CEEB", lightskyblue: "#87CEFA", blueviolet: "#8A2BE2", darkred: "#8B0000", darkmagenta: "#8B008B", saddlebrown: "#8B4513", darkseagreen: "#8FBC8F", lightgreen: "#90EE90", mediumpurple: "#9370DB", darkviolet: "#9400D3", palegreen: "#98FB98", darkorchid: "#9932CC", yellowgreen: "#9ACD32", sienna: "#A0522D", brown: "#A52A2A", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", lightblue: "#ADD8E6", greenyellow: "#ADFF2F", paleturquoise: "#AFEEEE", lightsteelblue: "#B0C4DE", powderblue: "#B0E0E6", firebrick: "#B22222", darkgoldenrod: "#B8860B", mediumorchid: "#BA55D3", rosybrown: "#BC8F8F", darkkhaki: "#BDB76B", mediumvioletred: "#C71585", indianred: "#CD5C5C", peru: "#CD853F", chocolate: "#D2691E", tan: "#D2B48C", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", thistle: "#D8BFD8", orchid: "#DA70D6", goldenrod: "#DAA520", palevioletred: "#DB7093", crimson: "#DC143C", gainsboro: "#DCDCDC", plum: "#DDA0DD", burlywood: "#DEB887", lightcyan: "#E0FFFF", lavender: "#E6E6FA", darksalmon: "#E9967A", violet: "#EE82EE", palegoldenrod: "#EEE8AA", lightcoral: "#F08080", khaki: "#F0E68C", aliceblue: "#F0F8FF", honeydew: "#F0FFF0", azure: "#F0FFFF", sandybrown: "#F4A460", wheat: "#F5DEB3", beige: "#F5F5DC", whitesmoke: "#F5F5F5", mintcream: "#F5FFFA", ghostwhite: "#F8F8FF", salmon: "#FA8072", antiquewhite: "#FAEBD7", linen: "#FAF0E6", lightgoldenrodyellow: "#FAFAD2", oldlace: "#FDF5E6", magenta: "#FF00FF", deeppink: "#FF1493", orangered: "#FF4500", tomato: "#FF6347", hotpink: "#FF69B4", coral: "#FF7F50", darkorange: "#FF8C00", lightsalmon: "#FFA07A", orange: "#FFA500", lightpink: "#FFB6C1", pink: "#FFC0CB", gold: "#FFD700", peachpuff: "#FFDAB9", navajowhite: "#FFDEAD", moccasin: "#FFE4B5", bisque: "#FFE4C4", mistyrose: "#FFE4E1", blanchedalmond: "#FFEBCD", papayawhip: "#FFEFD5", lavenderblush: "#FFF0F5", seashell: "#FFF5EE", cornsilk: "#FFF8DC", lemonchiffon: "#FFFACD", floralwhite: "#FFFAF0", snow: "#FFFAFA", lightyellow: "#FFFFE0", ivory: "#FFFFF0" } }, 8941: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.cubicInOut = t.cubicOut = t.cubicIn = t.quadraticInOut = t.quadraticOut = t.quadraticIn = t.linear = void 0, t.linear = function (e) { return e }, t.quadraticIn = function (e) { return e * e }, t.quadraticOut = function (e) { return e * (2 - e) }, t.quadraticInOut = function (e) { return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1) }, t.cubicIn = function (e) { return e * e * e }, t.cubicOut = function (e) { return --e * e * e + 1 }, t.cubicInOut = function (e) { return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2) }; var r = { linear: t.linear, quadraticIn: t.quadraticIn, quadraticOut: t.quadraticOut, quadraticInOut: t.quadraticInOut, cubicIn: t.cubicIn, cubicOut: t.cubicOut, cubicInOut: t.cubicInOut }; t.default = r }, 9822: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.doEdgeCollideWithPoint = t.isPixelColored = void 0, t.isPixelColored = function (e, t, r) { var n = new Uint8Array(4); return e.readPixels(t, e.drawingBufferHeight - r, 1, 1, e.RGBA, e.UNSIGNED_BYTE, n), n[3] > 0 }, t.doEdgeCollideWithPoint = function (e, t, r, n, i, o, a) { return !(e < r - a && e < i - a || t < n - a && t < o - a || e > r + a && e > i + a || t > n + a && t > o + a || !(Math.abs((i - r) * (n - t) - (r - e) * (o - n)) / Math.sqrt(Math.pow(i - r, 2) + Math.pow(o - n, 2)) < a / 2)) } }, 4524: function (e, t, r) { "use strict"; var n = this && this.__read || function (e, t) { var r = "function" == typeof Symbol && e[Symbol.iterator]; if (!r) return e; var n, i, o = r.call(e), a = []; try { for (; (void 0 === t || t-- > 0) && !(n = o.next()).done;)a.push(n.value) } catch (e) { i = { error: e } } finally { try { n && !n.done && (r = o.return) && r.call(o) } finally { if (i) throw i.error } } return a }, i = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.validateGraph = t.canUse32BitsIndices = t.extractPixel = t.getMatrixImpact = t.matrixFromCamera = t.getCorrectionRatio = t.floatColor = t.floatArrayColor = t.parseColor = t.zIndexOrdering = t.createNormalizationFunction = t.graphExtent = t.getPixelRatio = t.createElement = t.cancelFrame = t.requestFrame = t.assignDeep = t.assign = t.isPlainObject = void 0; var o = i(r(6186)), a = r(5132), s = r(8109); function c(e) { return "object" == typeof e && null !== e && e.constructor === Object } t.isPlainObject = c, t.assign = function (e) { for (var t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; e = e || {}; for (var n = 0, i = t.length; n < i; n++) { var o = t[n]; o && Object.assign(e, o) } return e }, t.assignDeep = function e(t) { for (var r = [], n = 1; n < arguments.length; n++)r[n - 1] = arguments[n]; t = t || {}; for (var i = 0, o = r.length; i < o; i++) { var a = r[i]; if (a) for (var s in a) c(a[s]) ? t[s] = e(t[s], a[s]) : t[s] = a[s] } return t }, t.requestFrame = "undefined" != typeof requestAnimationFrame ? function (e) { return requestAnimationFrame(e) } : function (e) { return setTimeout(e, 0) }, t.cancelFrame = "undefined" != typeof cancelAnimationFrame ? function (e) { return cancelAnimationFrame(e) } : function (e) { return clearTimeout(e) }, t.createElement = function (e, t, r) { var n = document.createElement(e); if (t) for (var i in t) n.style[i] = t[i]; if (r) for (var i in r) n.setAttribute(i, r[i]); return n }, t.getPixelRatio = function () { return void 0 !== window.devicePixelRatio ? window.devicePixelRatio : 1 }, t.graphExtent = function (e) { if (!e.order) return { x: [0, 1], y: [0, 1] }; var t = 1 / 0, r = -1 / 0, n = 1 / 0, i = -1 / 0; return e.forEachNode((function (e, o) { var a = o.x, s = o.y; a < t && (t = a), a > r && (r = a), s < n && (n = s), s > i && (i = s) })), { x: [t, r], y: [n, i] } }, t.createNormalizationFunction = function (e) { var t = n(e.x, 2), r = t[0], i = t[1], o = n(e.y, 2), a = o[0], s = o[1], c = Math.max(i - r, s - a), u = (i + r) / 2, h = (s + a) / 2; (0 === c || Math.abs(c) === 1 / 0 || isNaN(c)) && (c = 1), isNaN(u) && (u = 0), isNaN(h) && (h = 0); var d = function (e) { return { x: .5 + (e.x - u) / c, y: .5 + (e.y - h) / c } }; return d.applyTo = function (e) { e.x = .5 + (e.x - u) / c, e.y = .5 + (e.y - h) / c }, d.inverse = function (e) { return { x: u + c * (e.x - .5), y: h + c * (e.y - .5) } }, d.ratio = c, d }, t.zIndexOrdering = function (e, t, r) { return r.sort((function (e, r) { var n = t(e) || 0, i = t(r) || 0; return n < i ? -1 : n > i ? 1 : 0 })) }; var u = new Int8Array(4), h = new Int32Array(u.buffer, 0, 1), d = new Float32Array(u.buffer, 0, 1), l = /^\s*rgba?\s*\(/, p = /^\s*rgba?\s*\(\s*([0-9]*)\s*,\s*([0-9]*)\s*,\s*([0-9]*)(?:\s*,\s*(.*)?)?\)\s*$/; function f(e) { var t = 0, r = 0, n = 0, i = 1; if ("#" === e[0]) 4 === e.length ? (t = parseInt(e.charAt(1) + e.charAt(1), 16), r = parseInt(e.charAt(2) + e.charAt(2), 16), n = parseInt(e.charAt(3) + e.charAt(3), 16)) : (t = parseInt(e.charAt(1) + e.charAt(2), 16), r = parseInt(e.charAt(3) + e.charAt(4), 16), n = parseInt(e.charAt(5) + e.charAt(6), 16)); else if (l.test(e)) { var o = e.match(p); o && (t = +o[1], r = +o[2], n = +o[3], o[4] && (i = +o[4])) } return { r: t, g: r, b: n, a: i } } t.parseColor = f; var g = {}; for (var y in s.HTML_COLORS) g[y] = m(s.HTML_COLORS[y]), g[s.HTML_COLORS[y]] = g[y]; function m(e) { if (void 0 !== g[e]) return g[e]; var t = f(e), r = t.r, n = t.g, i = t.b, o = t.a; o = 255 * o | 0, h[0] = 4278190079 & (o << 24 | i << 16 | n << 8 | r); var a = d[0]; return g[e] = a, a } function v(e, t) { var r = e.height / e.width, n = t.height / t.width; return r < 1 && n > 1 || r > 1 && n < 1 ? 1 : Math.min(Math.max(n, 1 / n), Math.max(1 / r, r)) } t.floatArrayColor = function (e) { var t = f(e = s.HTML_COLORS[e] || e), r = t.r, n = t.g, i = t.b, o = t.a; return new Float32Array([r / 255, n / 255, i / 255, o]) }, t.floatColor = m, t.getCorrectionRatio = v, t.matrixFromCamera = function (e, t, r, n, i) { var o = e.angle, s = e.ratio, c = e.x, u = e.y, h = t.width, d = t.height, l = (0, a.identity)(), p = Math.min(h, d) - 2 * n, f = v(t, r); return i ? ((0, a.multiply)(l, (0, a.translate)((0, a.identity)(), c, u)), (0, a.multiply)(l, (0, a.scale)((0, a.identity)(), s)), (0, a.multiply)(l, (0, a.rotate)((0, a.identity)(), o)), (0, a.multiply)(l, (0, a.scale)((0, a.identity)(), h / p / 2 / f, d / p / 2 / f))) : ((0, a.multiply)(l, (0, a.scale)((0, a.identity)(), p / h * 2 * f, p / d * 2 * f)), (0, a.multiply)(l, (0, a.rotate)((0, a.identity)(), -o)), (0, a.multiply)(l, (0, a.scale)((0, a.identity)(), 1 / s)), (0, a.multiply)(l, (0, a.translate)((0, a.identity)(), -c, -u))), l }, t.getMatrixImpact = function (e, t, r) { var n = (0, a.multiplyVec2)(e, { x: Math.cos(t.angle), y: Math.sin(t.angle) }, 0), i = n.x, o = n.y; return 1 / Math.sqrt(Math.pow(i, 2) + Math.pow(o, 2)) / r.width }, t.extractPixel = function (e, t, r, n) { var i = n || new Uint8Array(4); return e.readPixels(t, r, 1, 1, e.RGBA, e.UNSIGNED_BYTE, i), i }, t.canUse32BitsIndices = function (e) { return "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || !!e.getExtension("OES_element_index_uint") }, t.validateGraph = function (e) { if (!(0, o.default)(e)) throw new Error("Sigma: invalid graph instance."); e.forEachNode((function (e, t) { if (!Number.isFinite(t.x) || !Number.isFinite(t.y)) throw new Error("Sigma: Coordinates of node ".concat(e, " are invalid. A node must have a numeric 'x' and 'y' attribute.")) })) } }, 5132: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.multiplyVec2 = t.multiply = t.translate = t.rotate = t.scale = t.identity = void 0, t.identity = function () { return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1) }, t.scale = function (e, t, r) { return e[0] = t, e[4] = "number" == typeof r ? r : t, e }, t.rotate = function (e, t) { var r = Math.sin(t), n = Math.cos(t); return e[0] = n, e[1] = r, e[3] = -r, e[4] = n, e }, t.translate = function (e, t, r) { return e[6] = t, e[7] = r, e }, t.multiply = function (e, t) { var r = e[0], n = e[1], i = e[2], o = e[3], a = e[4], s = e[5], c = e[6], u = e[7], h = e[8], d = t[0], l = t[1], p = t[2], f = t[3], g = t[4], y = t[5], m = t[6], v = t[7], b = t[8]; return e[0] = d * r + l * o + p * c, e[1] = d * n + l * a + p * u, e[2] = d * i + l * s + p * h, e[3] = f * r + g * o + y * c, e[4] = f * n + g * a + y * u, e[5] = f * i + g * s + y * h, e[6] = m * r + v * o + b * c, e[7] = m * n + v * a + b * u, e[8] = m * i + v * s + b * h, e }, t.multiplyVec2 = function (e, t, r) { void 0 === r && (r = 1); var n = e[0], i = e[1], o = e[3], a = e[4], s = e[6], c = e[7], u = t.x, h = t.y; return { x: u * n + h * o + s * r, y: u * i + h * a + c * r } } }, 3669: (e, t, r) => { t.formatArgs = function (t) { if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors) return; const r = "color: " + this.color; t.splice(1, 0, r, "color: inherit"); let n = 0, i = 0; t[0].replace(/%[a-zA-Z%]/g, (e => { "%%" !== e && (n++, "%c" === e && (i = n)) })), t.splice(i, 0, r) }, t.save = function (e) { try { e ? t.storage.setItem("debug", e) : t.storage.removeItem("debug") } catch (e) { } }, t.load = function () { let e; try { e = t.storage.getItem("debug") } catch (e) { } return !e && "undefined" != typeof process && "env" in process && (e = process.env.DEBUG), e }, t.useColors = function () { return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)) }, t.storage = function () { try { return localStorage } catch (e) { } }(), t.destroy = (() => { let e = !1; return () => { e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")) } })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => { }), e.exports = r(9231)(t); const { formatters: n } = e.exports; n.j = function (e) { try { return JSON.stringify(e) } catch (e) { return "[UnexpectedJSONParseError]: " + e.message } } }, 9231: (e, t, r) => { e.exports = function (e) { function t(e) { let r, i, o, a = null; function s(...e) { if (!s.enabled) return; const n = s, i = Number(new Date), o = i - (r || i); n.diff = o, n.prev = r, n.curr = i, r = i, e[0] = t.coerce(e[0]), "string" != typeof e[0] && e.unshift("%O"); let a = 0; e[0] = e[0].replace(/%([a-zA-Z%])/g, ((r, i) => { if ("%%" === r) return "%"; a++; const o = t.formatters[i]; if ("function" == typeof o) { const t = e[a]; r = o.call(n, t), e.splice(a, 1), a-- } return r })), t.formatArgs.call(n, e), (n.log || t.log).apply(n, e) } return s.namespace = e, s.useColors = t.useColors(), s.color = t.selectColor(e), s.extend = n, s.destroy = t.destroy, Object.defineProperty(s, "enabled", { enumerable: !0, configurable: !1, get: () => null !== a ? a : (i !== t.namespaces && (i = t.namespaces, o = t.enabled(e)), o), set: e => { a = e } }), "function" == typeof t.init && t.init(s), s } function n(e, r) { const n = t(this.namespace + (void 0 === r ? ":" : r) + e); return n.log = this.log, n } function i(e) { return e.toString().substring(2, e.toString().length - 2).replace(/\.\*\?$/, "*") } return t.debug = t, t.default = t, t.coerce = function (e) { return e instanceof Error ? e.stack || e.message : e }, t.disable = function () { const e = [...t.names.map(i), ...t.skips.map(i).map((e => "-" + e))].join(","); return t.enable(""), e }, t.enable = function (e) { let r; t.save(e), t.namespaces = e, t.names = [], t.skips = []; const n = ("string" == typeof e ? e : "").split(/[\s,]+/), i = n.length; for (r = 0; r < i; r++)n[r] && ("-" === (e = n[r].replace(/\*/g, ".*?"))[0] ? t.skips.push(new RegExp("^" + e.slice(1) + "$")) : t.names.push(new RegExp("^" + e + "$"))) }, t.enabled = function (e) { if ("*" === e[e.length - 1]) return !0; let r, n; for (r = 0, n = t.skips.length; r < n; r++)if (t.skips[r].test(e)) return !1; for (r = 0, n = t.names.length; r < n; r++)if (t.names[r].test(e)) return !0; return !1 }, t.humanize = r(4241), t.destroy = function () { console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.") }, Object.keys(e).forEach((r => { t[r] = e[r] })), t.names = [], t.skips = [], t.formatters = {}, t.selectColor = function (e) { let r = 0; for (let t = 0; t < e.length; t++)r = (r << 5) - r + e.charCodeAt(t), r |= 0; return t.colors[Math.abs(r) % t.colors.length] }, t.enable(t.load()), t } }, 4241: e => { var t = 1e3, r = 60 * t, n = 60 * r, i = 24 * n; function o(e, t, r, n) { var i = t >= 1.5 * r; return Math.round(e / r) + " " + n + (i ? "s" : "") } e.exports = function (e, a) { a = a || {}; var s, c, u = typeof e; if ("string" === u && e.length > 0) return function (e) { if (!((e = String(e)).length > 100)) { var o = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e); if (o) { var a = parseFloat(o[1]); switch ((o[2] || "ms").toLowerCase()) { case "years": case "year": case "yrs": case "yr": case "y": return 315576e5 * a; case "weeks": case "week": case "w": return 6048e5 * a; case "days": case "day": case "d": return a * i; case "hours": case "hour": case "hrs": case "hr": case "h": return a * n; case "minutes": case "minute": case "mins": case "min": case "m": return a * r; case "seconds": case "second": case "secs": case "sec": case "s": return a * t; case "milliseconds": case "millisecond": case "msecs": case "msec": case "ms": return a; default: return } } } }(e); if ("number" === u && isFinite(e)) return a.long ? (s = e, (c = Math.abs(s)) >= i ? o(s, c, i, "day") : c >= n ? o(s, c, n, "hour") : c >= r ? o(s, c, r, "minute") : c >= t ? o(s, c, t, "second") : s + " ms") : function (e) { var o = Math.abs(e); return o >= i ? Math.round(e / i) + "d" : o >= n ? Math.round(e / n) + "h" : o >= r ? Math.round(e / r) + "m" : o >= t ? Math.round(e / t) + "s" : e + "ms" }(e); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e)) } }, 8419: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.hasCORS = void 0; let r = !1; try { r = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest } catch (e) { } t.hasCORS = r }, 5754: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.decode = t.encode = void 0, t.encode = function (e) { let t = ""; for (let r in e) e.hasOwnProperty(r) && (t.length && (t += "&"), t += encodeURIComponent(r) + "=" + encodeURIComponent(e[r])); return t }, t.decode = function (e) { let t = {}, r = e.split("&"); for (let e = 0, n = r.length; e < n; e++) { let n = r[e].split("="); t[decodeURIComponent(n[0])] = decodeURIComponent(n[1]) } return t } }, 5222: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.parse = void 0; const r = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, n = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]; t.parse = function (e) { const t = e, i = e.indexOf("["), o = e.indexOf("]"); -1 != i && -1 != o && (e = e.substring(0, i) + e.substring(i, o).replace(/:/g, ";") + e.substring(o, e.length)); let a = r.exec(e || ""), s = {}, c = 14; for (; c--;)s[n[c]] = a[c] || ""; return -1 != i && -1 != o && (s.source = t, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0), s.pathNames = function (e, t) { const r = t.replace(/\/{2,9}/g, "/").split("/"); return "/" != t.substr(0, 1) && 0 !== t.length || r.splice(0, 1), "/" == t.substr(t.length - 1, 1) && r.splice(r.length - 1, 1), r }(0, s.path), s.queryKey = function (e, t) { const r = {}; return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, (function (e, t, n) { t && (r[t] = n) })), r }(0, s.query), s } }, 8726: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.yeast = t.decode = t.encode = void 0; const r = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), n = {}; let i, o = 0, a = 0; function s(e) { let t = ""; do { t = r[e % 64] + t, e = Math.floor(e / 64) } while (e > 0); return t } for (t.encode = s, t.decode = function (e) { let t = 0; for (a = 0; a < e.length; a++)t = 64 * t + n[e.charAt(a)]; return t }, t.yeast = function () { const e = s(+new Date); return e !== i ? (o = 0, i = e) : e + "." + s(o++) }; a < 64; a++)n[r[a]] = a }, 6242: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.globalThisShim = void 0, t.globalThisShim = "undefined" != typeof self ? self : "undefined" != typeof window ? window : Function("return this")() }, 4679: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.parse = t.installTimerFunctions = t.transports = t.Transport = t.protocol = t.Socket = void 0; const n = r(3481); Object.defineProperty(t, "Socket", { enumerable: !0, get: function () { return n.Socket } }), t.protocol = n.Socket.protocol; var i = r(9870); Object.defineProperty(t, "Transport", { enumerable: !0, get: function () { return i.Transport } }); var o = r(7385); Object.defineProperty(t, "transports", { enumerable: !0, get: function () { return o.transports } }); var a = r(9622); Object.defineProperty(t, "installTimerFunctions", { enumerable: !0, get: function () { return a.installTimerFunctions } }); var s = r(5222); Object.defineProperty(t, "parse", { enumerable: !0, get: function () { return s.parse } }) }, 3481: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.Socket = void 0; const i = r(7385), o = r(9622), a = r(5754), s = r(5222), c = n(r(4802)), u = r(5260), h = r(1373), d = (0, c.default)("engine.io-client:socket"); class l extends u.Emitter { constructor(e, t = {}) { super(), e && "object" == typeof e && (t = e, e = null), e ? (e = (0, s.parse)(e), t.hostname = e.host, t.secure = "https" === e.protocol || "wss" === e.protocol, t.port = e.port, e.query && (t.query = e.query)) : t.host && (t.hostname = (0, s.parse)(t.host).host), (0, o.installTimerFunctions)(this, t), this.secure = null != t.secure ? t.secure : "undefined" != typeof location && "https:" === location.protocol, t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || ("undefined" != typeof location ? location.hostname : "localhost"), this.port = t.port || ("undefined" != typeof location && location.port ? location.port : this.secure ? "443" : "80"), this.transports = t.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({ path: "/engine.io", agent: !1, withCredentials: !1, upgrade: !0, timestampParam: "t", rememberUpgrade: !1, rejectUnauthorized: !0, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: !0 }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + "/", "string" == typeof this.opts.query && (this.opts.query = (0, a.decode)(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, "function" == typeof addEventListener && (this.opts.closeOnBeforeunload && addEventListener("beforeunload", (() => { this.transport && (this.transport.removeAllListeners(), this.transport.close()) }), !1), "localhost" !== this.hostname && (this.offlineEventListener = () => { this.onClose("transport close", { description: "network connection lost" }) }, addEventListener("offline", this.offlineEventListener, !1))), this.open() } createTransport(e) { d('creating transport "%s"', e); const t = Object.assign({}, this.opts.query); t.EIO = h.protocol, t.transport = e, this.id && (t.sid = this.id); const r = Object.assign({}, this.opts.transportOptions[e], this.opts, { query: t, socket: this, hostname: this.hostname, secure: this.secure, port: this.port }); return d("options: %j", r), new i.transports[e](r) } open() { let e; if (this.opts.rememberUpgrade && l.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket")) e = "websocket"; else { if (0 === this.transports.length) return void this.setTimeoutFn((() => { this.emitReserved("error", "No transports available") }), 0); e = this.transports[0] } this.readyState = "opening"; try { e = this.createTransport(e) } catch (e) { return d("error while creating transport: %s", e), this.transports.shift(), void this.open() } e.open(), this.setTransport(e) } setTransport(e) { d("setting transport %s", e.name), this.transport && (d("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = e, e.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (e => this.onClose("transport close", e))) } probe(e) { d('probing transport "%s"', e); let t = this.createTransport(e), r = !1; l.priorWebsocketSuccess = !1; const n = () => { r || (d('probe transport "%s" opened', e), t.send([{ type: "ping", data: "probe" }]), t.once("packet", (n => { if (!r) if ("pong" === n.type && "probe" === n.data) { if (d('probe transport "%s" pong', e), this.upgrading = !0, this.emitReserved("upgrading", t), !t) return; l.priorWebsocketSuccess = "websocket" === t.name, d('pausing current transport "%s"', this.transport.name), this.transport.pause((() => { r || "closed" !== this.readyState && (d("changing transport and sending upgrade packet"), u(), this.setTransport(t), t.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t), t = null, this.upgrading = !1, this.flush()) })) } else { d('probe transport "%s" failed', e); const r = new Error("probe error"); r.transport = t.name, this.emitReserved("upgradeError", r) } }))) }; function i() { r || (r = !0, u(), t.close(), t = null) } const o = r => { const n = new Error("probe error: " + r); n.transport = t.name, i(), d('probe transport "%s" failed because of error: %s', e, r), this.emitReserved("upgradeError", n) }; function a() { o("transport closed") } function s() { o("socket closed") } function c(e) { t && e.name !== t.name && (d('"%s" works - aborting "%s"', e.name, t.name), i()) } const u = () => { t.removeListener("open", n), t.removeListener("error", o), t.removeListener("close", a), this.off("close", s), this.off("upgrading", c) }; t.once("open", n), t.once("error", o), t.once("close", a), this.once("close", s), this.once("upgrading", c), t.open() } onOpen() { if (d("socket open"), this.readyState = "open", l.priorWebsocketSuccess = "websocket" === this.transport.name, this.emitReserved("open"), this.flush(), "open" === this.readyState && this.opts.upgrade && this.transport.pause) { d("starting upgrade probes"); let e = 0; const t = this.upgrades.length; for (; e < t; e++)this.probe(this.upgrades[e]) } } onPacket(e) { if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (d('socket receive: type "%s", data "%s"', e.type, e.data), this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) { case "open": this.onHandshake(JSON.parse(e.data)); break; case "ping": this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"); break; case "error": const t = new Error("server error"); t.code = e.data, this.onError(t); break; case "message": this.emitReserved("data", e.data), this.emitReserved("message", e.data) } else d('packet received with socket readyState "%s"', this.readyState) } onHandshake(e) { this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.maxPayload = e.maxPayload, this.onOpen(), "closed" !== this.readyState && this.resetPingTimeout() } resetPingTimeout() { this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn((() => { this.onClose("ping timeout") }), this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref() } onDrain() { this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emitReserved("drain") : this.flush() } flush() { if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) { const e = this.getWritablePackets(); d("flushing %d packets in socket", e.length), this.transport.send(e), this.prevBufferLen = e.length, this.emitReserved("flush") } } getWritablePackets() { if (!(this.maxPayload && "polling" === this.transport.name && this.writeBuffer.length > 1)) return this.writeBuffer; let e = 1; for (let t = 0; t < this.writeBuffer.length; t++) { const r = this.writeBuffer[t].data; if (r && (e += (0, o.byteLength)(r)), t > 0 && e > this.maxPayload) return d("only send %d out of %d packets", t, this.writeBuffer.length), this.writeBuffer.slice(0, t); e += 2 } return d("payload size is %d (max: %d)", e, this.maxPayload), this.writeBuffer } write(e, t, r) { return this.sendPacket("message", e, t, r), this } send(e, t, r) { return this.sendPacket("message", e, t, r), this } sendPacket(e, t, r, n) { if ("function" == typeof t && (n = t, t = void 0), "function" == typeof r && (n = r, r = null), "closing" === this.readyState || "closed" === this.readyState) return; (r = r || {}).compress = !1 !== r.compress; const i = { type: e, data: t, options: r }; this.emitReserved("packetCreate", i), this.writeBuffer.push(i), n && this.once("flush", n), this.flush() } close() { const e = () => { this.onClose("forced close"), d("socket closing - telling transport to close"), this.transport.close() }, t = () => { this.off("upgrade", t), this.off("upgradeError", t), e() }, r = () => { this.once("upgrade", t), this.once("upgradeError", t) }; return "opening" !== this.readyState && "open" !== this.readyState || (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", (() => { this.upgrading ? r() : e() })) : this.upgrading ? r() : e()), this } onError(e) { d("socket error %j", e), l.priorWebsocketSuccess = !1, this.emitReserved("error", e), this.onClose("transport error", e) } onClose(e, t) { "opening" !== this.readyState && "open" !== this.readyState && "closing" !== this.readyState || (d('socket close with reason: "%s"', e), this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), "function" == typeof removeEventListener && removeEventListener("offline", this.offlineEventListener, !1), this.readyState = "closed", this.id = null, this.emitReserved("close", e, t), this.writeBuffer = [], this.prevBufferLen = 0) } filterUpgrades(e) { const t = []; let r = 0; const n = e.length; for (; r < n; r++)~this.transports.indexOf(e[r]) && t.push(e[r]); return t } } t.Socket = l, l.protocol = h.protocol }, 9870: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.Transport = void 0; const i = r(1373), o = r(5260), a = r(9622), s = (0, n(r(4802)).default)("engine.io-client:transport"); class c extends Error { constructor(e, t, r) { super(e), this.description = t, this.context = r, this.type = "TransportError" } } class u extends o.Emitter { constructor(e) { super(), this.writable = !1, (0, a.installTimerFunctions)(this, e), this.opts = e, this.query = e.query, this.readyState = "", this.socket = e.socket } onError(e, t, r) { return super.emitReserved("error", new c(e, t, r)), this } open() { return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", this.doOpen()), this } close() { return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this } send(e) { "open" === this.readyState ? this.write(e) : s("transport is not open, discarding packets") } onOpen() { this.readyState = "open", this.writable = !0, super.emitReserved("open") } onData(e) { const t = (0, i.decodePacket)(e, this.socket.binaryType); this.onPacket(t) } onPacket(e) { super.emitReserved("packet", e) } onClose(e) { this.readyState = "closed", super.emitReserved("close", e) } } t.Transport = u }, 7385: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.transports = void 0; const n = r(484), i = r(1308); t.transports = { websocket: i.WS, polling: n.Polling } }, 484: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.Request = t.Polling = void 0; const i = r(9870), o = n(r(4802)), a = r(8726), s = r(5754), c = r(1373), u = r(6666), h = r(5260), d = r(9622), l = r(6242), p = (0, o.default)("engine.io-client:polling"); function f() { } const g = null != new u.XHR({ xdomain: !1 }).responseType; class y extends i.Transport { constructor(e) { if (super(e), this.polling = !1, "undefined" != typeof location) { const t = "https:" === location.protocol; let r = location.port; r || (r = t ? "443" : "80"), this.xd = "undefined" != typeof location && e.hostname !== location.hostname || r !== e.port, this.xs = e.secure !== t } const t = e && e.forceBase64; this.supportsBinary = g && !t } get name() { return "polling" } doOpen() { this.poll() } pause(e) { this.readyState = "pausing"; const t = () => { p("paused"), this.readyState = "paused", e() }; if (this.polling || !this.writable) { let e = 0; this.polling && (p("we are currently polling - waiting to pause"), e++, this.once("pollComplete", (function () { p("pre-pause polling complete"), --e || t() }))), this.writable || (p("we are currently writing - waiting to pause"), e++, this.once("drain", (function () { p("pre-pause writing complete"), --e || t() }))) } else t() } poll() { p("polling"), this.polling = !0, this.doPoll(), this.emitReserved("poll") } onData(e) { p("polling got data %s", e), (0, c.decodePayload)(e, this.socket.binaryType).forEach((e => { if ("opening" === this.readyState && "open" === e.type && this.onOpen(), "close" === e.type) return this.onClose({ description: "transport closed by the server" }), !1; this.onPacket(e) })), "closed" !== this.readyState && (this.polling = !1, this.emitReserved("pollComplete"), "open" === this.readyState ? this.poll() : p('ignoring poll - transport state "%s"', this.readyState)) } doClose() { const e = () => { p("writing close packet"), this.write([{ type: "close" }]) }; "open" === this.readyState ? (p("transport open - closing"), e()) : (p("transport not open - deferring close"), this.once("open", e)) } write(e) { this.writable = !1, (0, c.encodePayload)(e, (e => { this.doWrite(e, (() => { this.writable = !0, this.emitReserved("drain") })) })) } uri() { let e = this.query || {}; const t = this.opts.secure ? "https" : "http"; let r = ""; !1 !== this.opts.timestampRequests && (e[this.opts.timestampParam] = (0, a.yeast)()), this.supportsBinary || e.sid || (e.b64 = 1), this.opts.port && ("https" === t && 443 !== Number(this.opts.port) || "http" === t && 80 !== Number(this.opts.port)) && (r = ":" + this.opts.port); const n = (0, s.encode)(e); return t + "://" + (-1 !== this.opts.hostname.indexOf(":") ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (n.length ? "?" + n : "") } request(e = {}) { return Object.assign(e, { xd: this.xd, xs: this.xs }, this.opts), new m(this.uri(), e) } doWrite(e, t) { const r = this.request({ method: "POST", data: e }); r.on("success", t), r.on("error", ((e, t) => { this.onError("xhr post error", e, t) })) } doPoll() { p("xhr poll"); const e = this.request(); e.on("data", this.onData.bind(this)), e.on("error", ((e, t) => { this.onError("xhr poll error", e, t) })), this.pollXhr = e } } t.Polling = y; class m extends h.Emitter { constructor(e, t) { super(), (0, d.installTimerFunctions)(this, t), this.opts = t, this.method = t.method || "GET", this.uri = e, this.async = !1 !== t.async, this.data = void 0 !== t.data ? t.data : null, this.create() } create() { const e = (0, d.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref"); e.xdomain = !!this.opts.xd, e.xscheme = !!this.opts.xs; const t = this.xhr = new u.XHR(e); try { p("xhr open %s: %s", this.method, this.uri), t.open(this.method, this.uri, this.async); try { if (this.opts.extraHeaders) { t.setDisableHeaderCheck && t.setDisableHeaderCheck(!0); for (let e in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(e) && t.setRequestHeader(e, this.opts.extraHeaders[e]) } } catch (e) { } if ("POST" === this.method) try { t.setRequestHeader("Content-type", "text/plain;charset=UTF-8") } catch (e) { } try { t.setRequestHeader("Accept", "*/*") } catch (e) { } "withCredentials" in t && (t.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (t.timeout = this.opts.requestTimeout), t.onreadystatechange = () => { 4 === t.readyState && (200 === t.status || 1223 === t.status ? this.onLoad() : this.setTimeoutFn((() => { this.onError("number" == typeof t.status ? t.status : 0) }), 0)) }, p("xhr data %s", this.data), t.send(this.data) } catch (e) { return void this.setTimeoutFn((() => { this.onError(e) }), 0) } "undefined" != typeof document && (this.index = m.requestsCount++, m.requests[this.index] = this) } onError(e) { this.emitReserved("error", e, this.xhr), this.cleanup(!0) } cleanup(e) { if (void 0 !== this.xhr && null !== this.xhr) { if (this.xhr.onreadystatechange = f, e) try { this.xhr.abort() } catch (e) { } "undefined" != typeof document && delete m.requests[this.index], this.xhr = null } } onLoad() { const e = this.xhr.responseText; null !== e && (this.emitReserved("data", e), this.emitReserved("success"), this.cleanup()) } abort() { this.cleanup() } } if (t.Request = m, m.requestsCount = 0, m.requests = {}, "undefined" != typeof document) if ("function" == typeof attachEvent) attachEvent("onunload", v); else if ("function" == typeof addEventListener) { const e = "onpagehide" in l.globalThisShim ? "pagehide" : "unload"; addEventListener(e, v, !1) } function v() { for (let e in m.requests) m.requests.hasOwnProperty(e) && m.requests[e].abort() } }, 5552: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.defaultBinaryType = t.usingBrowserWebSocket = t.WebSocket = t.nextTick = void 0; const n = r(6242); t.nextTick = "function" == typeof Promise && "function" == typeof Promise.resolve ? e => Promise.resolve().then(e) : (e, t) => t(e, 0), t.WebSocket = n.globalThisShim.WebSocket || n.globalThisShim.MozWebSocket, t.usingBrowserWebSocket = !0, t.defaultBinaryType = "arraybuffer" }, 1308: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.WS = void 0; const i = r(9870), o = r(5754), a = r(8726), s = r(9622), c = r(5552), u = n(r(4802)), h = r(1373), d = (0, u.default)("engine.io-client:websocket"), l = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase(); class p extends i.Transport { constructor(e) { super(e), this.supportsBinary = !e.forceBase64 } get name() { return "websocket" } doOpen() { if (!this.check()) return; const e = this.uri(), t = this.opts.protocols, r = l ? {} : (0, s.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity"); this.opts.extraHeaders && (r.headers = this.opts.extraHeaders); try { this.ws = c.usingBrowserWebSocket && !l ? t ? new c.WebSocket(e, t) : new c.WebSocket(e) : new c.WebSocket(e, t, r) } catch (e) { return this.emitReserved("error", e) } this.ws.binaryType = this.socket.binaryType || c.defaultBinaryType, this.addEventListeners() } addEventListeners() { this.ws.onopen = () => { this.opts.autoUnref && this.ws._socket.unref(), this.onOpen() }, this.ws.onclose = e => this.onClose({ description: "websocket connection closed", context: e }), this.ws.onmessage = e => this.onData(e.data), this.ws.onerror = e => this.onError("websocket error", e) } write(e) { this.writable = !1; for (let t = 0; t < e.length; t++) { const r = e[t], n = t === e.length - 1; (0, h.encodePacket)(r, this.supportsBinary, (e => { const t = {}; !c.usingBrowserWebSocket && (r.options && (t.compress = r.options.compress), this.opts.perMessageDeflate) && ("string" == typeof e ? Buffer.byteLength(e) : e.length) < this.opts.perMessageDeflate.threshold && (t.compress = !1); try { c.usingBrowserWebSocket ? this.ws.send(e) : this.ws.send(e, t) } catch (e) { d("websocket closed before onclose event") } n && (0, c.nextTick)((() => { this.writable = !0, this.emitReserved("drain") }), this.setTimeoutFn) })) } } doClose() { void 0 !== this.ws && (this.ws.close(), this.ws = null) } uri() { let e = this.query || {}; const t = this.opts.secure ? "wss" : "ws"; let r = ""; this.opts.port && ("wss" === t && 443 !== Number(this.opts.port) || "ws" === t && 80 !== Number(this.opts.port)) && (r = ":" + this.opts.port), this.opts.timestampRequests && (e[this.opts.timestampParam] = (0, a.yeast)()), this.supportsBinary || (e.b64 = 1); const n = (0, o.encode)(e); return t + "://" + (-1 !== this.opts.hostname.indexOf(":") ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (n.length ? "?" + n : "") } check() { return !!c.WebSocket } } t.WS = p }, 6666: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.XHR = void 0; const n = r(8419), i = r(6242); t.XHR = function (e) { const t = e.xdomain; try { if ("undefined" != typeof XMLHttpRequest && (!t || n.hasCORS)) return new XMLHttpRequest } catch (e) { } if (!t) try { return new (i.globalThisShim[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP") } catch (e) { } } }, 9622: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.byteLength = t.installTimerFunctions = t.pick = void 0; const n = r(6242); t.pick = function (e, ...t) { return t.reduce(((t, r) => (e.hasOwnProperty(r) && (t[r] = e[r]), t)), {}) }; const i = setTimeout, o = clearTimeout; t.installTimerFunctions = function (e, t) { t.useNativeTimers ? (e.setTimeoutFn = i.bind(n.globalThisShim), e.clearTimeoutFn = o.bind(n.globalThisShim)) : (e.setTimeoutFn = setTimeout.bind(n.globalThisShim), e.clearTimeoutFn = clearTimeout.bind(n.globalThisShim)) }, t.byteLength = function (e) { return "string" == typeof e ? function (e) { let t = 0, r = 0; for (let n = 0, i = e.length; n < i; n++)t = e.charCodeAt(n), t < 128 ? r += 1 : t < 2048 ? r += 2 : t < 55296 || t >= 57344 ? r += 3 : (n++, r += 4); return r }(e) : Math.ceil(1.33 * (e.byteLength || e.size)) } }, 3087: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.ERROR_PACKET = t.PACKET_TYPES_REVERSE = t.PACKET_TYPES = void 0; const r = Object.create(null); t.PACKET_TYPES = r, r.open = "0", r.close = "1", r.ping = "2", r.pong = "3", r.message = "4", r.upgrade = "5", r.noop = "6"; const n = Object.create(null); t.PACKET_TYPES_REVERSE = n, Object.keys(r).forEach((e => { n[r[e]] = e })), t.ERROR_PACKET = { type: "error", data: "parser error" } }, 2469: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.decode = t.encode = void 0; const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256); for (let e = 0; e < r.length; e++)n[r.charCodeAt(e)] = e; t.encode = e => { let t, n = new Uint8Array(e), i = n.length, o = ""; for (t = 0; t < i; t += 3)o += r[n[t] >> 2], o += r[(3 & n[t]) << 4 | n[t + 1] >> 4], o += r[(15 & n[t + 1]) << 2 | n[t + 2] >> 6], o += r[63 & n[t + 2]]; return i % 3 == 2 ? o = o.substring(0, o.length - 1) + "=" : i % 3 == 1 && (o = o.substring(0, o.length - 2) + "=="), o }, t.decode = e => { let t, r, i, o, a, s = .75 * e.length, c = e.length, u = 0; "=" === e[e.length - 1] && (s--, "=" === e[e.length - 2] && s--); const h = new ArrayBuffer(s), d = new Uint8Array(h); for (t = 0; t < c; t += 4)r = n[e.charCodeAt(t)], i = n[e.charCodeAt(t + 1)], o = n[e.charCodeAt(t + 2)], a = n[e.charCodeAt(t + 3)], d[u++] = r << 2 | i >> 4, d[u++] = (15 & i) << 4 | o >> 2, d[u++] = (3 & o) << 6 | 63 & a; return h } }, 7572: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); const n = r(3087), i = r(2469), o = "function" == typeof ArrayBuffer, a = (e, t) => { if (o) { const r = (0, i.decode)(e); return s(r, t) } return { base64: !0, data: e } }, s = (e, t) => "blob" === t && e instanceof ArrayBuffer ? new Blob([e]) : e; t.default = (e, t) => { if ("string" != typeof e) return { type: "message", data: s(e, t) }; const r = e.charAt(0); return "b" === r ? { type: "message", data: a(e.substring(1), t) } : n.PACKET_TYPES_REVERSE[r] ? e.length > 1 ? { type: n.PACKET_TYPES_REVERSE[r], data: e.substring(1) } : { type: n.PACKET_TYPES_REVERSE[r] } : n.ERROR_PACKET } }, 3908: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); const n = r(3087), i = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === Object.prototype.toString.call(Blob), o = "function" == typeof ArrayBuffer, a = (e, t) => { const r = new FileReader; return r.onload = function () { const e = r.result.split(",")[1]; t("b" + e) }, r.readAsDataURL(e) }; t.default = ({ type: e, data: t }, r, s) => { return i && t instanceof Blob ? r ? s(t) : a(t, s) : o && (t instanceof ArrayBuffer || (c = t, "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(c) : c && c.buffer instanceof ArrayBuffer)) ? r ? s(t) : a(new Blob([t]), s) : s(n.PACKET_TYPES[e] + (t || "")); var c } }, 1373: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.decodePayload = t.decodePacket = t.encodePayload = t.encodePacket = t.protocol = void 0; const n = r(3908); t.encodePacket = n.default; const i = r(7572); t.decodePacket = i.default; const o = String.fromCharCode(30); t.encodePayload = (e, t) => { const r = e.length, i = new Array(r); let a = 0; e.forEach(((e, s) => { (0, n.default)(e, !1, (e => { i[s] = e, ++a === r && t(i.join(o)) })) })) }, t.decodePayload = (e, t) => { const r = e.split(o), n = []; for (let e = 0; e < r.length; e++) { const o = (0, i.default)(r[e], t); if (n.push(o), "error" === o.type) break } return n }, t.protocol = 4 }, 5159: (e, t) => { "use strict"; function r(e) { e = e || {}, this.ms = e.min || 100, this.max = e.max || 1e4, this.factor = e.factor || 2, this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0, this.attempts = 0 } Object.defineProperty(t, "__esModule", { value: !0 }), t.Backoff = void 0, t.Backoff = r, r.prototype.duration = function () { var e = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var t = Math.random(), r = Math.floor(t * this.jitter * e); e = 0 == (1 & Math.floor(10 * t)) ? e - r : e + r } return 0 | Math.min(e, this.max) }, r.prototype.reset = function () { this.attempts = 0 }, r.prototype.setMin = function (e) { this.ms = e }, r.prototype.setMax = function (e) { this.max = e }, r.prototype.setJitter = function (e) { this.jitter = e } }, 7046: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.connect = t.io = t.Socket = t.Manager = t.protocol = void 0; const i = r(3084), o = r(4168); Object.defineProperty(t, "Manager", { enumerable: !0, get: function () { return o.Manager } }); const a = r(8312); Object.defineProperty(t, "Socket", { enumerable: !0, get: function () { return a.Socket } }); const s = n(r(3669)).default("socket.io-client"), c = {}; function u(e, t) { "object" == typeof e && (t = e, e = void 0), t = t || {}; const r = i.url(e, t.path || "/socket.io"), n = r.source, a = r.id, u = r.path, h = c[a] && u in c[a].nsps; let d; return t.forceNew || t["force new connection"] || !1 === t.multiplex || h ? (s("ignoring socket cache for %s", n), d = new o.Manager(n, t)) : (c[a] || (s("new io instance for %s", n), c[a] = new o.Manager(n, t)), d = c[a]), r.query && !t.query && (t.query = r.queryKey), d.socket(r.path, t) } t.io = u, t.connect = u, t.default = u, Object.assign(u, { Manager: o.Manager, Socket: a.Socket, io: u, connect: u }); var h = r(7116); Object.defineProperty(t, "protocol", { enumerable: !0, get: function () { return h.protocol } }), e.exports = u }, 4168: function (e, t, r) { "use strict"; var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) { void 0 === n && (n = r), Object.defineProperty(e, n, { enumerable: !0, get: function () { return t[r] } }) } : function (e, t, r, n) { void 0 === n && (n = r), e[n] = t[r] }), i = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), o = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r); return i(t, e), t }, a = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.Manager = void 0; const s = r(4679), c = r(8312), u = o(r(7116)), h = r(7149), d = r(5159), l = r(5260), p = a(r(3669)).default("socket.io-client:manager"); class f extends l.Emitter { constructor(e, t) { var r; super(), this.nsps = {}, this.subs = [], e && "object" == typeof e && (t = e, e = void 0), (t = t || {}).path = t.path || "/socket.io", this.opts = t, s.installTimerFunctions(this, t), this.reconnection(!1 !== t.reconnection), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor(null !== (r = t.randomizationFactor) && void 0 !== r ? r : .5), this.backoff = new d.Backoff({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(null == t.timeout ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e; const n = t.parser || u; this.encoder = new n.Encoder, this.decoder = new n.Decoder, this._autoConnect = !1 !== t.autoConnect, this._autoConnect && this.open() } reconnection(e) { return arguments.length ? (this._reconnection = !!e, this) : this._reconnection } reconnectionAttempts(e) { return void 0 === e ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this) } reconnectionDelay(e) { var t; return void 0 === e ? this._reconnectionDelay : (this._reconnectionDelay = e, null === (t = this.backoff) || void 0 === t || t.setMin(e), this) } randomizationFactor(e) { var t; return void 0 === e ? this._randomizationFactor : (this._randomizationFactor = e, null === (t = this.backoff) || void 0 === t || t.setJitter(e), this) } reconnectionDelayMax(e) { var t; return void 0 === e ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, null === (t = this.backoff) || void 0 === t || t.setMax(e), this) } timeout(e) { return arguments.length ? (this._timeout = e, this) : this._timeout } maybeReconnectOnOpen() { !this._reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect() } open(e) { if (p("readyState %s", this._readyState), ~this._readyState.indexOf("open")) return this; p("opening %s", this.uri), this.engine = new s.Socket(this.uri, this.opts); const t = this.engine, r = this; this._readyState = "opening", this.skipReconnect = !1; const n = h.on(t, "open", (function () { r.onopen(), e && e() })), i = h.on(t, "error", (t => { p("error"), r.cleanup(), r._readyState = "closed", this.emitReserved("error", t), e ? e(t) : r.maybeReconnectOnOpen() })); if (!1 !== this._timeout) { const e = this._timeout; p("connect attempt will timeout after %d", e), 0 === e && n(); const r = this.setTimeoutFn((() => { p("connect attempt timed out after %d", e), n(), t.close(), t.emit("error", new Error("timeout")) }), e); this.opts.autoUnref && r.unref(), this.subs.push((function () { clearTimeout(r) })) } return this.subs.push(n), this.subs.push(i), this } connect(e) { return this.open(e) } onopen() { p("open"), this.cleanup(), this._readyState = "open", this.emitReserved("open"); const e = this.engine; this.subs.push(h.on(e, "ping", this.onping.bind(this)), h.on(e, "data", this.ondata.bind(this)), h.on(e, "error", this.onerror.bind(this)), h.on(e, "close", this.onclose.bind(this)), h.on(this.decoder, "decoded", this.ondecoded.bind(this))) } onping() { this.emitReserved("ping") } ondata(e) { this.decoder.add(e) } ondecoded(e) { this.emitReserved("packet", e) } onerror(e) { p("error", e), this.emitReserved("error", e) } socket(e, t) { let r = this.nsps[e]; return r || (r = new c.Socket(this, e, t), this.nsps[e] = r), r } _destroy(e) { const t = Object.keys(this.nsps); for (const e of t) if (this.nsps[e].active) return void p("socket %s is still active, skipping close", e); this._close() } _packet(e) { p("writing packet %j", e); const t = this.encoder.encode(e); for (let r = 0; r < t.length; r++)this.engine.write(t[r], e.options) } cleanup() { p("cleanup"), this.subs.forEach((e => e())), this.subs.length = 0, this.decoder.destroy() } _close() { p("disconnect"), this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close() } disconnect() { return this._close() } onclose(e, t) { p("closed due to %s", e), this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, t), this._reconnection && !this.skipReconnect && this.reconnect() } reconnect() { if (this._reconnecting || this.skipReconnect) return this; const e = this; if (this.backoff.attempts >= this._reconnectionAttempts) p("reconnect failed"), this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1; else { const t = this.backoff.duration(); p("will wait %dms before reconnect attempt", t), this._reconnecting = !0; const r = this.setTimeoutFn((() => { e.skipReconnect || (p("attempting reconnect"), this.emitReserved("reconnect_attempt", e.backoff.attempts), e.skipReconnect || e.open((t => { t ? (p("reconnect attempt error"), e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", t)) : (p("reconnect success"), e.onreconnect()) }))) }), t); this.opts.autoUnref && r.unref(), this.subs.push((function () { clearTimeout(r) })) } } onreconnect() { const e = this.backoff.attempts; this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e) } } t.Manager = f }, 7149: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.on = void 0, t.on = function (e, t, r) { return e.on(t, r), function () { e.off(t, r) } } }, 8312: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.Socket = void 0; const i = r(7116), o = r(7149), a = r(5260), s = n(r(3669)).default("socket.io-client:socket"), c = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 }); class u extends a.Emitter { constructor(e, t, r) { super(), this.connected = !1, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, r && r.auth && (this.auth = r.auth), this.io._autoConnect && this.open() } get disconnected() { return !this.connected } subEvents() { if (this.subs) return; const e = this.io; this.subs = [o.on(e, "open", this.onopen.bind(this)), o.on(e, "packet", this.onpacket.bind(this)), o.on(e, "error", this.onerror.bind(this)), o.on(e, "close", this.onclose.bind(this))] } get active() { return !!this.subs } connect() { return this.connected || (this.subEvents(), this.io._reconnecting || this.io.open(), "open" === this.io._readyState && this.onopen()), this } open() { return this.connect() } send(...e) { return e.unshift("message"), this.emit.apply(this, e), this } emit(e, ...t) { if (c.hasOwnProperty(e)) throw new Error('"' + e + '" is a reserved event name'); t.unshift(e); const r = { type: i.PacketType.EVENT, data: t, options: {} }; if (r.options.compress = !1 !== this.flags.compress, "function" == typeof t[t.length - 1]) { const e = this.ids++; s("emitting packet with ack id %d", e); const n = t.pop(); this._registerAckCallback(e, n), r.id = e } const n = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable; return !this.flags.volatile || n && this.connected ? this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r) : s("discard packet as the transport is not currently writable"), this.flags = {}, this } _registerAckCallback(e, t) { const r = this.flags.timeout; if (void 0 === r) return void (this.acks[e] = t); const n = this.io.setTimeoutFn((() => { delete this.acks[e]; for (let t = 0; t < this.sendBuffer.length; t++)this.sendBuffer[t].id === e && (s("removing packet with ack id %d from the buffer", e), this.sendBuffer.splice(t, 1)); s("event with ack id %d has timed out after %d ms", e, r), t.call(this, new Error("operation has timed out")) }), r); this.acks[e] = (...e) => { this.io.clearTimeoutFn(n), t.apply(this, [null, ...e]) } } packet(e) { e.nsp = this.nsp, this.io._packet(e) } onopen() { s("transport is open - connecting"), "function" == typeof this.auth ? this.auth((e => { this.packet({ type: i.PacketType.CONNECT, data: e }) })) : this.packet({ type: i.PacketType.CONNECT, data: this.auth }) } onerror(e) { this.connected || this.emitReserved("connect_error", e) } onclose(e, t) { s("close (%s)", e), this.connected = !1, delete this.id, this.emitReserved("disconnect", e, t) } onpacket(e) { if (e.nsp === this.nsp) switch (e.type) { case i.PacketType.CONNECT: if (e.data && e.data.sid) { const t = e.data.sid; this.onconnect(t) } else this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)")); break; case i.PacketType.EVENT: case i.PacketType.BINARY_EVENT: this.onevent(e); break; case i.PacketType.ACK: case i.PacketType.BINARY_ACK: this.onack(e); break; case i.PacketType.DISCONNECT: this.ondisconnect(); break; case i.PacketType.CONNECT_ERROR: this.destroy(); const t = new Error(e.data.message); t.data = e.data.data, this.emitReserved("connect_error", t) } } onevent(e) { const t = e.data || []; s("emitting event %j", t), null != e.id && (s("attaching ack callback to event"), t.push(this.ack(e.id))), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t)) } emitEvent(e) { if (this._anyListeners && this._anyListeners.length) { const t = this._anyListeners.slice(); for (const r of t) r.apply(this, e) } super.emit.apply(this, e) } ack(e) { const t = this; let r = !1; return function (...n) { r || (r = !0, s("sending ack %j", n), t.packet({ type: i.PacketType.ACK, id: e, data: n })) } } onack(e) { const t = this.acks[e.id]; "function" == typeof t ? (s("calling ack %s with %j", e.id, e.data), t.apply(this, e.data), delete this.acks[e.id]) : s("bad ack %s", e.id) } onconnect(e) { s("socket connected with id %s", e), this.id = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect") } emitBuffered() { this.receiveBuffer.forEach((e => this.emitEvent(e))), this.receiveBuffer = [], this.sendBuffer.forEach((e => { this.notifyOutgoingListeners(e), this.packet(e) })), this.sendBuffer = [] } ondisconnect() { s("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect") } destroy() { this.subs && (this.subs.forEach((e => e())), this.subs = void 0), this.io._destroy(this) } disconnect() { return this.connected && (s("performing disconnect (%s)", this.nsp), this.packet({ type: i.PacketType.DISCONNECT })), this.destroy(), this.connected && this.onclose("io client disconnect"), this } close() { return this.disconnect() } compress(e) { return this.flags.compress = e, this } get volatile() { return this.flags.volatile = !0, this } timeout(e) { return this.flags.timeout = e, this } onAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this } prependAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this } offAny(e) { if (!this._anyListeners) return this; if (e) { const t = this._anyListeners; for (let r = 0; r < t.length; r++)if (e === t[r]) return t.splice(r, 1), this } else this._anyListeners = []; return this } listenersAny() { return this._anyListeners || [] } onAnyOutgoing(e) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this } prependAnyOutgoing(e) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this } offAnyOutgoing(e) { if (!this._anyOutgoingListeners) return this; if (e) { const t = this._anyOutgoingListeners; for (let r = 0; r < t.length; r++)if (e === t[r]) return t.splice(r, 1), this } else this._anyOutgoingListeners = []; return this } listenersAnyOutgoing() { return this._anyOutgoingListeners || [] } notifyOutgoingListeners(e) { if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) { const t = this._anyOutgoingListeners.slice(); for (const r of t) r.apply(this, e.data) } } } t.Socket = u }, 3084: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.url = void 0; const i = r(4679), o = n(r(3669)).default("socket.io-client:url"); t.url = function (e, t = "", r) { let n = e; r = r || "undefined" != typeof location && location, null == e && (e = r.protocol + "//" + r.host), "string" == typeof e && ("/" === e.charAt(0) && (e = "/" === e.charAt(1) ? r.protocol + e : r.host + e), /^(https?|wss?):\/\//.test(e) || (o("protocol-less url %s", e), e = void 0 !== r ? r.protocol + "//" + e : "https://" + e), o("parse %s", e), n = i.parse(e)), n.port || (/^(http|ws)$/.test(n.protocol) ? n.port = "80" : /^(http|ws)s$/.test(n.protocol) && (n.port = "443")), n.path = n.path || "/"; const a = -1 !== n.host.indexOf(":") ? "[" + n.host + "]" : n.host; return n.id = n.protocol + "://" + a + ":" + n.port + t, n.href = n.protocol + "://" + a + (r && r.port === n.port ? "" : ":" + n.port), n } }, 3155: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.reconstructPacket = t.deconstructPacket = void 0; const n = r(790); function i(e, t) { if (!e) return e; if (n.isBinary(e)) { const r = { _placeholder: !0, num: t.length }; return t.push(e), r } if (Array.isArray(e)) { const r = new Array(e.length); for (let n = 0; n < e.length; n++)r[n] = i(e[n], t); return r } if ("object" == typeof e && !(e instanceof Date)) { const r = {}; for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (r[n] = i(e[n], t)); return r } return e } function o(e, t) { if (!e) return e; if (e && e._placeholder) return t[e.num]; if (Array.isArray(e)) for (let r = 0; r < e.length; r++)e[r] = o(e[r], t); else if ("object" == typeof e) for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (e[r] = o(e[r], t)); return e } t.deconstructPacket = function (e) { const t = [], r = e.data, n = e; return n.data = i(r, t), n.attachments = t.length, { packet: n, buffers: t } }, t.reconstructPacket = function (e, t) { return e.data = o(e.data, t), e.attachments = void 0, e } }, 7116: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.Decoder = t.Encoder = t.PacketType = t.protocol = void 0; const n = r(5260), i = r(3155), o = r(790), a = r(3669).default("socket.io-parser"); var s; t.protocol = 5, function (e) { e[e.CONNECT = 0] = "CONNECT", e[e.DISCONNECT = 1] = "DISCONNECT", e[e.EVENT = 2] = "EVENT", e[e.ACK = 3] = "ACK", e[e.CONNECT_ERROR = 4] = "CONNECT_ERROR", e[e.BINARY_EVENT = 5] = "BINARY_EVENT", e[e.BINARY_ACK = 6] = "BINARY_ACK" }(s = t.PacketType || (t.PacketType = {})), t.Encoder = class { constructor(e) { this.replacer = e } encode(e) { return a("encoding packet %j", e), e.type !== s.EVENT && e.type !== s.ACK || !o.hasBinary(e) ? [this.encodeAsString(e)] : (e.type = e.type === s.EVENT ? s.BINARY_EVENT : s.BINARY_ACK, this.encodeAsBinary(e)) } encodeAsString(e) { let t = "" + e.type; return e.type !== s.BINARY_EVENT && e.type !== s.BINARY_ACK || (t += e.attachments + "-"), e.nsp && "/" !== e.nsp && (t += e.nsp + ","), null != e.id && (t += e.id), null != e.data && (t += JSON.stringify(e.data, this.replacer)), a("encoded %j as %s", e, t), t } encodeAsBinary(e) { const t = i.deconstructPacket(e), r = this.encodeAsString(t.packet), n = t.buffers; return n.unshift(r), n } }; class c extends n.Emitter { constructor(e) { super(), this.reviver = e } add(e) { let t; if ("string" == typeof e) t = this.decodeString(e), t.type === s.BINARY_EVENT || t.type === s.BINARY_ACK ? (this.reconstructor = new u(t), 0 === t.attachments && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t); else { if (!o.isBinary(e) && !e.base64) throw new Error("Unknown type: " + e); if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet"); t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved("decoded", t)) } } decodeString(e) { let t = 0; const r = { type: Number(e.charAt(0)) }; if (void 0 === s[r.type]) throw new Error("unknown packet type " + r.type); if (r.type === s.BINARY_EVENT || r.type === s.BINARY_ACK) { const n = t + 1; for (; "-" !== e.charAt(++t) && t != e.length;); const i = e.substring(n, t); if (i != Number(i) || "-" !== e.charAt(t)) throw new Error("Illegal attachments"); r.attachments = Number(i) } if ("/" === e.charAt(t + 1)) { const n = t + 1; for (; ++t && "," !== e.charAt(t) && t !== e.length;); r.nsp = e.substring(n, t) } else r.nsp = "/"; const n = e.charAt(t + 1); if ("" !== n && Number(n) == n) { const n = t + 1; for (; ++t;) { const r = e.charAt(t); if (null == r || Number(r) != r) { --t; break } if (t === e.length) break } r.id = Number(e.substring(n, t + 1)) } if (e.charAt(++t)) { const n = this.tryParse(e.substr(t)); if (!c.isPayloadValid(r.type, n)) throw new Error("invalid payload"); r.data = n } return a("decoded %s as %j", e, r), r } tryParse(e) { try { return JSON.parse(e, this.reviver) } catch (e) { return !1 } } static isPayloadValid(e, t) { switch (e) { case s.CONNECT: return "object" == typeof t; case s.DISCONNECT: return void 0 === t; case s.CONNECT_ERROR: return "string" == typeof t || "object" == typeof t; case s.EVENT: case s.BINARY_EVENT: return Array.isArray(t) && t.length > 0; case s.ACK: case s.BINARY_ACK: return Array.isArray(t) } } destroy() { this.reconstructor && this.reconstructor.finishedReconstruction() } } t.Decoder = c; class u { constructor(e) { this.packet = e, this.buffers = [], this.reconPack = e } takeBinaryData(e) { if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) { const e = i.reconstructPacket(this.reconPack, this.buffers); return this.finishedReconstruction(), e } return null } finishedReconstruction() { this.reconPack = null, this.buffers = [] } } }, 790: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.hasBinary = t.isBinary = void 0; const r = "function" == typeof ArrayBuffer, n = Object.prototype.toString, i = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === n.call(Blob), o = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === n.call(File); function a(e) { return r && (e instanceof ArrayBuffer || (e => "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer)(e)) || i && e instanceof Blob || o && e instanceof File } t.isBinary = a, t.hasBinary = function e(t, r) { if (!t || "object" != typeof t) return !1; if (Array.isArray(t)) { for (let r = 0, n = t.length; r < n; r++)if (e(t[r])) return !0; return !1 } if (a(t)) return !0; if (t.toJSON && "function" == typeof t.toJSON && 1 === arguments.length) return e(t.toJSON(), !0); for (const r in t) if (Object.prototype.hasOwnProperty.call(t, r) && e(t[r])) return !0; return !1 } }, 5260: (e, t, r) => { "use strict"; function n(e) { if (e) return function (e) { for (var t in n.prototype) e[t] = n.prototype[t]; return e }(e) } r.r(t), r.d(t, { Emitter: () => n }), n.prototype.on = n.prototype.addEventListener = function (e, t) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this }, n.prototype.once = function (e, t) { function r() { this.off(e, r), t.apply(this, arguments) } return r.fn = t, this.on(e, r), this }, n.prototype.off = n.prototype.removeListener = n.prototype.removeAllListeners = n.prototype.removeEventListener = function (e, t) { if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this; var r, n = this._callbacks["$" + e]; if (!n) return this; if (1 == arguments.length) return delete this._callbacks["$" + e], this; for (var i = 0; i < n.length; i++)if ((r = n[i]) === t || r.fn === t) { n.splice(i, 1); break } return 0 === n.length && delete this._callbacks["$" + e], this }, n.prototype.emit = function (e) { this._callbacks = this._callbacks || {}; for (var t = new Array(arguments.length - 1), r = this._callbacks["$" + e], n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; if (r) { n = 0; for (var i = (r = r.slice(0)).length; n < i; ++n)r[n].apply(this, t) } return this }, n.prototype.emitReserved = n.prototype.emit, n.prototype.listeners = function (e) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || [] }, n.prototype.hasListeners = function (e) { return !!this.listeners(e).length } } }, t = {}; function r(n) { var i = t[n]; if (void 0 !== i) return i.exports; var o = t[n] = { exports: {} }; return e[n].call(o.exports, o, o.exports, r), o.exports } r.d = (e, t) => { for (var n in t) r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), r.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, (() => { "use strict"; var e = r(9026), t = r(7046), n = r(9404), i = r(2698), o = document.getElementById("sigma-container"), a = document.getElementById("zoom-in"), s = document.getElementById("zoom-out"), c = document.getElementById("zoom-reset"), u = document.getElementById("labels-threshold"); t.io().on("connection", (function (t) { console.log("hello there"); var r = new i.default; r.import(t); var h = n.default.inferSettings(r); n.default.assign(r, { iterations: 50, settings: h }), console.log(t); var d = new e.Sigma(r, o, { minCameraRatio: .1, maxCameraRatio: 10 }), l = d.getCamera(); a.addEventListener("click", (function () { l.animatedZoom({ duration: 600 }) })), s.addEventListener("click", (function () { l.animatedUnzoom({ duration: 600 }) })), c.addEventListener("click", (function () { l.animatedReset({ duration: 600 }) })), u.addEventListener("input", (function () { d.setSetting("labelRenderedSizeThreshold", +u.value) })), u.value = d.getSetting("labelRenderedSizeThreshold") + "" })) })() })();